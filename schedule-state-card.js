const TRANSLATIONS = {
    en: {
        state_label: "State",
        condition_label: "Condition",
        layer_label: "Schedule Rule",
        time_label: "Time Slots",
        no_specific_condition: "No specific condition",
        default_state_label: "Default state",
        wrapping: "wrapping",
        no_schedule: "No schedule",
        entity_not_found: "Entity not found",
        dynamic_value: "Dynamic value",
        dynamic_ref_schedule: "schedule_state",
        dynamic_ref_sensor: "sensor",
        cond_days: "Days",
        cond_month: "Month",
        cond_and: "AND",
        cond_or: "OR",
        cond_not: "NOT",
        cond_sunrise: "Sunrise",
        cond_sunset: "Sunset",
        cond_combined_result: "Combined Schedule",
        cond_combined_schedule_toggle: "Combined Schedule Result (Click to show/hide rules)",
        cond_after: "after",
        cond_before: "before",
        days: {
            mon: "Monday",
            tue: "Tuesday",
            wed: "Wednesday",
            thu: "Thursday",
            fri: "Friday",
            sat: "Saturday",
            sun: "Sunday"
        },
        editor_title: "Schedule State Card Editor",
        editor_card_title: "Card Title",
        editor_entities_label: "Entities",
        editor_add_entity: "Add Entity",
        editor_entity_id_label: "Entity ID",
        editor_name_label: "Name",
        editor_icon_label: "Icon (mdi:)",
        editor_placeholder_name: "Display Name",
        editor_handle: "Handle",
        editor_actions: "Actions",
        editor_default_entity_name: "Entity",
        editor_no_entities: "No entities",
        editor_title_placeholder: "Schedule Planning",
        editor_no_entities_found: "No entities found",
        editor_colors_label: "Colors Configuration",
        editor_active_layer_label: "Active Layer Color",
        editor_inactive_layer_label: "Inactive Layer Color",
        editor_combined_folded_label: "Combined Icon Color (Folded)",
        editor_combined_unfolded_label: "Combined Icon Color (Unfolded)",
        editor_cursor_label: "Time Cursor Color",
        editor_color_hex_label: "Hex Color",
        editor_color_picker_label: "Color Picker",
        editor_show_state_in_title: "Show state value in header",
        common: {
            edit: "Edit",
            delete: "Delete"
        }
    },
    fr: {
        state_label: "État",
        condition_label: "Condition",
        layer_label: "Règle de planning",
        time_label: "Plages horaires",
        no_specific_condition: "Aucune condition spécifique",
        default_state_label: "État par défaut",
        wrapping: "débordement",
        no_schedule: "Pas de planning",
        entity_not_found: "Entité non trouvée",
        dynamic_value: "Valeur dynamique",
        dynamic_ref_schedule: "état_planning",
        dynamic_ref_sensor: "capteur",
        cond_days: "Jours",
        cond_month: "Mois",
        cond_and: "ET",
        cond_or: "OU",
        cond_not: "NON",
        cond_sunrise: "Lever du soleil",
        cond_sunset: "Coucher du soleil",
        cond_combined_result: "Planning Combiné",
        cond_combined_schedule_toggle: "Résultat du Planning Combiné (Cliquez pour afficher/masquer les règles)",
        cond_after: "après",
        cond_before: "avant",
        days: {
            mon: "Lundi",
            tue: "Mardi",
            wed: "Mercredi",
            thu: "Jeudi",
            fri: "Vendredi",
            sat: "Samedi",
            sun: "Dimanche"
        },
        editor_title: "Éditeur de Carte d'État de Planning",
        editor_card_title: "Titre de la Carte",
        editor_entities_label: "Entités",
        editor_add_entity: "Ajouter une Entité",
        editor_entity_id_label: "ID d'Entité",
        editor_name_label: "Nom",
        editor_icon_label: "Icône (mdi:)",
        editor_placeholder_name: "Nom d'affichage",
        editor_handle: "Poignée",
        editor_actions: "Actions",
        editor_default_entity_name: "Entité",
        editor_no_entities: "Aucune entité",
        editor_title_placeholder: "Planning d'Horaires",
        editor_no_entities_found: "Aucune entité trouvée",
        editor_colors_label: "Configuration des Couleurs",
        editor_active_layer_label: "Couleur de la Couche Active",
        editor_inactive_layer_label: "Couleur de la Couche Inactive",
        editor_combined_folded_label: "Couleur de l'Icône Combinée (Pliée)",
        editor_combined_unfolded_label: "Couleur de l'Icône Combinée (Dépliée)",
        editor_cursor_label: "Couleur du Curseur Temporel",
        editor_color_hex_label: "Couleur Hex",
        editor_color_picker_label: "Sélecteur de Couleur",
        editor_show_state_in_title: "Afficher la valeur d'état dans l'en-tête",
        common: {
            edit: "Éditer",
            delete: "Supprimer"
        }
    },
    de: {
        state_label: "Status",
        condition_label: "Bedingung",
        layer_label: "Zeitplanregel",
        time_label: "Zeitfenster",
        no_specific_condition: "Keine spezifische Bedingung",
        default_state_label: "Standardstatus",
        wrapping: "Überlauf",
        no_schedule: "Kein Zeitplan",
        entity_not_found: "Entität nicht gefunden",
        dynamic_value: "Dynamischer Wert",
        dynamic_ref_schedule: "Zeitplan-Status",
        dynamic_ref_sensor: "Sensor",
        cond_days: "Tage",
        cond_month: "Monat",
        cond_and: "UND",
        cond_or: "ODER",
        cond_not: "NICHT",
        cond_sunrise: "Sonnenaufgang",
        cond_sunset: "Sonnenuntergang",
        cond_combined_result: "Kombinierter Zeitplan",
        cond_combined_schedule_toggle: "Ergebnis des kombinierten Zeitplans (Klicken zum Anzeigen/Ausblenden der Regeln)",
        cond_after: "nach",
        cond_before: "vor",
        days: {
            mon: "Montag",
            tue: "Dienstag",
            wed: "Mittwoch",
            thu: "Donnerstag",
            fri: "Freitag",
            sat: "Samstag",
            sun: "Sonntag"
        },
        editor_title: "Zeitplan-Status-Karten-Editor",
        editor_card_title: "Kartentitel",
        editor_entities_label: "Entitäten",
        editor_add_entity: "Entität hinzufügen",
        editor_entity_id_label: "Entitäts-ID",
        editor_name_label: "Name",
        editor_icon_label: "Icon (mdi:)",
        editor_placeholder_name: "Anzeigename",
        editor_handle: "Griff",
        editor_actions: "Aktionen",
        editor_default_entity_name: "Entität",
        editor_no_entities: "Keine Entitäten",
        editor_title_placeholder: "Zeitplan-Planung",
        editor_no_entities_found: "Keine Entitäten gefunden",
        editor_colors_label: "Farbkonfiguration",
        editor_active_layer_label: "Farbe der aktiven Schicht",
        editor_inactive_layer_label: "Farbe der inaktiven Schicht",
        editor_combined_folded_label: "Kombinierte Symbolfarbe (Zusammengeklappt)",
        editor_combined_unfolded_label: "Kombinierte Symbolfarbe (Erweitert)",
        editor_cursor_label: "Zeitzeiger-Farbe",
        editor_color_hex_label: "Hex-Farbe",
        editor_color_picker_label: "Farbwähler",
        editor_show_state_in_title: "Zustandswert in der Kopfzeile anzeigen",
        common: {
            edit: "Bearbeiten",
            delete: "Löschen"
        }
    },
    es: {
        state_label: "Estado",
        condition_label: "Condición",
        layer_label: "Regla de horario",
        time_label: "Intervalos",
        no_specific_condition: "Sin condición específica",
        default_state_label: "Estado por defecto",
        wrapping: "desbordamiento",
        no_schedule: "Sin horario",
        entity_not_found: "Entidad no encontrada",
        dynamic_value: "Valor dinámico",
        dynamic_ref_schedule: "estado_horario",
        dynamic_ref_sensor: "sensor",
        cond_days: "Días",
        cond_month: "Mes",
        cond_and: "Y",
        cond_or: "O",
        cond_not: "NO",
        cond_sunrise: "Amanecer",
        cond_sunset: "Atardecer",
        cond_combined_result: "Horario Combinado",
        cond_combined_schedule_toggle: "Resultado del Horario Combinado (Clic para mostrar/ocultar reglas)",
        cond_after: "después de",
        cond_before: "antes de",
        days: {
            mon: "Lunes",
            tue: "Martes",
            wed: "Miércoles",
            thu: "Jueves",
            fri: "Viernes",
            sat: "Sábado",
            sun: "Domingo"
        },
        editor_title: "Editor de Tarjeta de Estado de Horario",
        editor_card_title: "Título de la Tarjeta",
        editor_entities_label: "Entidades",
        editor_add_entity: "Añadir Entidad",
        editor_entity_id_label: "ID de Entidad",
        editor_name_label: "Nombre",
        editor_icon_label: "Icono (mdi:)",
        editor_placeholder_name: "Nombre de visualización",
        editor_handle: "Mango",
        editor_actions: "Acciones",
        editor_default_entity_name: "Entidad",
        editor_no_entities: "Sin entidades",
        editor_title_placeholder: "Planificación de Horarios",
        editor_no_entities_found: "No se encontraron entidades",
        editor_colors_label: "Configuración de Colores",
        editor_active_layer_label: "Color de Capa Activa",
        editor_inactive_layer_label: "Color de Capa Inactiva",
        editor_combined_folded_label: "Color del Icono Combinado (Plegado)",
        editor_combined_unfolded_label: "Color del Icono Combinado (Expandido)",
        editor_cursor_label: "Color del Cursor Temporal",
        editor_color_hex_label: "Color Hex",
        editor_color_picker_label: "Selector de Color",
        editor_show_state_in_title: "Mostrar valor de estado en el encabezado",
        common: {
            edit: "Editar",
            delete: "Eliminar"
        }
    },
    pt: {
        state_label: "Estado",
        condition_label: "Condição",
        layer_label: "Regra de Agenda",
        time_label: "Intervalos de Tempo",
        no_specific_condition: "Sem condição específica",
        default_state_label: "Estado padrão",
        wrapping: "empacotamento",
        no_schedule: "Sem agenda",
        entity_not_found: "Entidade não encontrada",
        dynamic_value: "Valor dinâmico",
        dynamic_ref_schedule: "estado_agenda",
        dynamic_ref_sensor: "sensor",
        cond_days: "Dias",
        cond_month: "Mês",
        cond_and: "E",
        cond_or: "OU",
        cond_not: "NÃO",
        cond_sunrise: "Nascer do sol",
        cond_sunset: "Pôr do sol",
        cond_combined_result: "Agenda Combinada",
        cond_combined_schedule_toggle: "Resultado da Agenda Combinada (Clique para mostrar/ocultar regras)",
        cond_after: "después de",
        cond_before: "antes de",
        days: {
            mon: "Segunda-feira",
            tue: "Terça-feira",
            wed: "Quarta-feira",
            thu: "Quinta-feira",
            fri: "Sexta-feira",
            sat: "Sábado",
            sun: "Domingo"
        },
        editor_title: "Editor do Cartão de Estado da Agenda",
        editor_card_title: "Título do Cartão",
        editor_entities_label: "Entidades",
        editor_add_entity: "Adicionar Entidade",
        editor_entity_id_label: "ID da Entidade",
        editor_name_label: "Nome",
        editor_icon_label: "Ícone (mdi:)",
        editor_placeholder_name: "Nome de Exibição",
        editor_handle: "Manipulador",
        editor_actions: "Ações",
        editor_default_entity_name: "Entidade",
        editor_no_entities: "Sem entidades",
        editor_title_placeholder: "Planejamento de Agenda",
        editor_no_entities_found: "Nenhuma entidade encontrada",
        editor_colors_label: "Configuração de Cores",
        editor_active_layer_label: "Cor da Camada Ativa",
        editor_inactive_layer_label: "Cor da Camada Inativa",
        editor_combined_folded_label: "Combined Icon Color (Folded)",
        editor_combined_unfolded_label: "Combined Icon Color (Unfolded)",
        editor_cursor_label: "Cor do Cursor Temporal",
        editor_color_hex_label: "Cor Hex",
        editor_color_picker_label: "Seletor de Cor",
        editor_show_state_in_title: "Mostrar valor de estado no cabeçalho",
        common: {
            edit: "Editar",
            delete: "Excluir"
        }
    },
    pt_BR: {
        state_label: "Estado",
        condition_label: "Condição",
        layer_label: "Regra de Programação",
        time_label: "Períodos de Tempo",
        no_specific_condition: "Sem condição específica",
        default_state_label: "Estado padrão",
        wrapping: "empacotamento",
        no_schedule: "Sem programação",
        entity_not_found: "Entidade não encontrada",
        dynamic_value: "Valor dinâmico",
        dynamic_ref_schedule: "estado_programação",
        dynamic_ref_sensor: "sensor",
        cond_days: "Dias",
        cond_month: "Mês",
        cond_and: "E",
        cond_or: "OU",
        cond_not: "NÃO",
        cond_sunrise: "Nascer do sol",
        cond_sunset: "Pôr do sol",
        cond_combined_result: "Programação Combinada",
        cond_combined_schedule_toggle: "Resultado da Programação Combinada (Clique para mostrar/ocultar regras)",
        cond_after: "após",
        cond_before: "antes de",
        days: {
            mon: "Segunda-feira",
            tue: "Terça-feira",
            wed: "Quarta-feira",
            thu: "Quinta-feira",
            fri: "Sexta-feira",
            sat: "Sábado",
            sun: "Domingo"
        },
        editor_title: "Editor do Cartão de Estado da Programação",
        editor_card_title: "Título do Cartão",
        editor_entities_label: "Entidades",
        editor_add_entity: "Adicionar Entidade",
        editor_entity_id_label: "ID da Entidade",
        editor_name_label: "Nome",
        editor_icon_label: "Ícone (mdi:)",
        editor_placeholder_name: "Nome de Exibição",
        editor_handle: "Manipulador",
        editor_actions: "Ações",
        editor_default_entity_name: "Entidade",
        editor_no_entities: "Nenhuma entidade",
        editor_title_placeholder: "Planejamento de Programação",
        editor_no_entities_found: "Nenhuma entidade encontrada",
        editor_colors_label: "Configuração de Cores",
        editor_active_layer_label: "Cor da Camada Ativa",
        editor_inactive_layer_label: "Cor da Camada Inativa",
        editor_combined_folded_label: "Combined Icon Color (Folded)",
        editor_combined_unfolded_label: "Combined Icon Color (Unfolded)",
        editor_cursor_label: "Cor do Cursor Temporal",
        editor_color_hex_label: "Cor Hex",
        editor_color_picker_label: "Seletor de Cor",
        editor_show_state_in_title: "Mostrar valor de estado no cabeçalho",
        common: {
            edit: "Editar",
            delete: "Excluir"
        }
    }
};

const DEFAULT_COLORS = {
    active_layer: "var(--primary-color, #2196F3)",
    inactive_layer: "var(--secondary-text-color, #BDBDBD)",
    combined_folded_layer: "var(--warning-color, #FF9800)",
    combined_unfolded_layer: "var(--primary-color, #2196F3)",
    cursor: "var(--label-badge-yellow, #FDD835)"
};

/**
 * Centralized translation patterns for condition text
 * Maps regex patterns to their translation handlers
 */
const CONDITION_TRANSLATION_PATTERNS = [
    // Time-based translations (order matters: sunrise before "sun" abbreviations)
    {
        pattern: /\bSunrise\s+condition\b/g,
        key: 'cond_sunrise',
        type: 'simple'
    },
    {
        pattern: /\bSunset\s+condition\b/g,
        key: 'cond_sunset',
        type: 'simple'
    },
    {
        pattern: /\bSunrise\s+after\s+/g,
        template: (t) => `${t('cond_sunrise')} ${t('cond_after')} `,
        type: 'template'
    },
    {
        pattern: /\bSunrise\s+before\s+/g,
        template: (t) => `${t('cond_sunrise')} ${t('cond_before')} `,
        type: 'template'
    },
    {
        pattern: /\bSunset\s+after\s+/g,
        template: (t) => `${t('cond_sunset')} ${t('cond_after')} `,
        type: 'template'
    },
    {
        pattern: /\bSunset\s+before\s+/g,
        template: (t) => `${t('cond_sunset')} ${t('cond_before')} `,
        type: 'template'
    },
    {
        pattern: /\bSunrise\s+>/g,
        template: (t) => `${t('cond_sunrise')} >`,
        type: 'template'
    },
    {
        pattern: /\bSunrise\s+</g,
        template: (t) => `${t('cond_sunrise')} <`,
        type: 'template'
    },
    {
        pattern: /\bSunset\s+>/g,
        template: (t) => `${t('cond_sunset')} >`,
        type: 'template'
    },
    {
        pattern: /\bSunset\s+</g,
        template: (t) => `${t('cond_sunset')} <`,
        type: 'template'
    },

    // Label translations (must come after sunrise/sunset to avoid conflicts)
    {
        pattern: /\bDays:/g,
        key: 'cond_days',
        type: 'labelSuffix'
    },
    {
        pattern: /\bMonth:/g,
        key: 'cond_month',
        type: 'labelSuffix'
    },

    // Logic operators
    {
        pattern: /\sAND\s/g,
        key: 'cond_and',
        type: 'operator'
    },
    {
        pattern: /\sOR\s/g,
        key: 'cond_or',
        type: 'operator'
    },
    {
        pattern: /\bNOT\s+\(/g,
        key: 'cond_not',
        type: 'notOperator'
    }
];

/**
 * Day abbreviations to full day key mapping
 * Used for translating day abbreviations in condition text
 */
const DAY_ABBREVIATION_MAP = {
    "Mon": "mon",
    "Tue": "tue",
    "Wed": "wed",
    "Thu": "thu",
    "Fri": "fri",
    "Sat": "sat",
    "Sun": "sun"
};

/**
 * Centralized layout constants
 * Eliminates magic numbers throughout the codebase
 */
const LAYOUT_CONSTANTS = {
    BLOCK_HEIGHT: 20,
    VERTICAL_GAP: 8,
    TOP_MARGIN: 4,
    BOTTOM_MARGIN: 20,
    ICON_COLUMN_WIDTH: 28,
    MOUSE_STABILIZATION_DELAY: 200,
    DEBOUNCE_DELAY_MS: 500,
    TIMELINE_UPDATE_INTERVAL_MS: 60000, // 1 minute
    MINUTES_PER_DAY: 1440, // 24 * 60
    FULL_ROTATION_DEGREES: 360,
    COLOR_HUE_INCREMENT: 60,
    TOOLTIP_OFFSET_Y: 25,
    TOOLTIP_MARGIN_X: 10,
    TOOLTIP_HIDE_DELAY_MS: 50,
    TOOLTIP_SHOW_DELAY_MS: 200
};

/**
 * Escape HTML special characters for safe text content display
 * "/" is NOT escaped as it's safe in text and common in units (€/kWh, m/s, etc.)
 * @param {string} text - Text to escape
 * @returns {string} Escaped text safe for innerHTML
 */
function escapeHtml(text) {
    if (!text) return "";
    const str = String(text);
    const map = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
    };
    return str.replace(/[&<>"']/g, char => map[char]);
}

/**
 * Escape HTML special characters for safe attribute values
 * More strict than escapeHtml - escapes "/" to prevent attribute breakout
 * @param {string} text - Text to escape
 * @returns {string} Escaped text safe for HTML attributes
 */
function escapeHtmlAttribute(text) {
    if (!text) return "";
    const str = String(text);
    const map = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;"
    };
    return str.replace(/[&<>"'/]/g, char => map[char]);
}

class LanguageHelper {
    /**
     * Centralized language management to eliminate code duplication
     * Used by both ScheduleStateCard and ScheduleStateCardEditor
     */
    constructor(hass) {
        this._hass = hass;
    }

    getLanguage() {
        if (this._hass?.locale?.language) {
            return TRANSLATIONS[this._hass.locale.language] ? this._hass.locale.language : "en";
        }
        return "en";
    }

    t(key) {
        const lang = this.getLanguage();
        return TRANSLATIONS[lang]?.[key] || TRANSLATIONS.en[key] || key;
    }

    setHass(hass) {
        this._hass = hass;
    }
}

class AppState {
    constructor() {
        // Layer visibility state - tracks which entity layers are expanded/collapsed
        this.layerVisibility = new Map();

        // Timer references - tracks all active timeouts
        this.timers = {
            debounce: null,
            tooltip: null
        };

        // Cache storage - for expensive calculations
        this.caches = {
            colors: new Map(), // Color calculations by state value
            dom: null // DOM metrics (container width, etc.)
        };

        // Timing tracking - for debounce logic
        this.lastUpdateTime = 0;

        // Event listener reference - for cleanup on disconnect
        this.eventListener = null;
    }

    /**
     * Check if a layer is visible (expanded) for a given entity
     * @param {string} entityId - Home Assistant entity ID
     * @returns {boolean} True if layer is visible
     */
    isLayerVisible(entityId) {
        return this.layerVisibility.get(entityId) === true;
    }

    /**
     * Toggle layer visibility for an entity
     * @param {string} entityId - Home Assistant entity ID
     */
    toggleLayerVisibility(entityId) {
        const current = this.layerVisibility.get(entityId);
        this.layerVisibility.set(entityId, !current);
    }

    /**
     * Set layer visibility state
     * @param {string} entityId - Home Assistant entity ID
     * @param {boolean} visible - New visibility state
     */
    setLayerVisibility(entityId, visible) {
        this.layerVisibility.set(entityId, visible);
    }

    /**
     * Initialize visibility for an entity if not already set
     * @param {string} entityId - Home Assistant entity ID
     * @param {boolean} defaultValue - Default visibility (typically true)
     */
    initializeLayerVisibility(entityId, defaultValue = true) {
        if (!this.layerVisibility.has(entityId)) {
            this.layerVisibility.set(entityId, defaultValue);
        }
    }

    /**
     * Set a timer and clear any previous timer with same key
     * @param {string} timerKey - Timer identifier ('debounce', 'tooltip', etc.)
     * @param {number} timeoutId - Timeout ID to track
     */
    setTimer(timerKey, timeoutId) {
        if (this.timers[timerKey]) {
            clearTimeout(this.timers[timerKey]);
        }
        this.timers[timerKey] = timeoutId;
    }

    /**
     * Clear a specific timer
     * @param {string} timerKey - Timer identifier
     */
    clearTimer(timerKey) {
        if (this.timers[timerKey]) {
            clearTimeout(this.timers[timerKey]);
            this.timers[timerKey] = null;
        }
    }

    /**
     * Clear all active timers
     */
    clearAllTimers() {
        Object.keys(this.timers).forEach(key => this.clearTimer(key));
    }

    /**
     * Invalidate DOM cache to force recalculation
     */
    invalidateDOMCache() {
        this.caches.dom = null;
    }

    /**
     * Set cached DOM metrics
     * @param {object} metrics - Object containing {containerWidth: number}
     */
    setDOMMetrics(metrics) {
        this.caches.dom = metrics;
    }

    /**
     * Get cached DOM metrics or null if not cached
     * @returns {object|null} Cached metrics or null
     */
    getDOMMetrics() {
        return this.caches.dom;
    }

    /**
     * Invalidate all caches to force recalculation
     */
    invalidateAllCaches() {
        this.caches.colors.clear();
        this.caches.dom = null;
    }

    /**
     * Update timing information for debounce logic
     * @param {number} timestamp - Current timestamp (from Date.now())
     */
    updateLastUpdateTime(timestamp) {
        this.lastUpdateTime = timestamp;
    }

    /**
     * Get elapsed time since last update
     * @returns {number} Milliseconds elapsed
     */
    getTimeSinceLastUpdate() {
        return Date.now() - this.lastUpdateTime;
    }

    /**
     * Complete cleanup for disconnection
     * Clears all timers, caches, and resets state
     */
    resetOnDisconnect() {
        this.clearAllTimers();
        this.invalidateAllCaches();
        this.layerVisibility.clear();
        this.eventListener = null;
        this.lastUpdateTime = 0;
    }

    /**
     * Log current state for debugging
     */
    debug() {
        console.log('AppState Debug:', {
            visibleLayers: Array.from(this.layerVisibility.entries()),
            timers: Object.keys(this.timers).reduce((acc, key) => {
                acc[key] = this.timers[key] !== null ? 'active' : 'null';
                return acc;
            }, {}),
            cachedDOMMetrics: this.caches.dom !== null,
            colorCacheSize: this.caches.colors.size,
            lastUpdateTime: this.lastUpdateTime
        });
    }
}

class ScheduleStateCard extends HTMLElement {
    static get BLOCK_HEIGHT() {
        return 20;
    }
    static get VERTICAL_GAP() {
        return 8;
    }
    static get TOP_MARGIN() {
        return 4;
    }
    static get BOTTOM_MARGIN() {
        return 20;
    }
    static get ICON_COLUMN_WIDTH() {
        return 28;
    }
    static get MOUSE_STABILIZATION_DELAY() {
        return 200;
    }

    constructor() {
        super();
        this.attachShadow({
            mode: "open"
        });

        // CENTRALIZED STATE - Single source of truth
        this._state = new AppState();
        this._langHelper = new LanguageHelper(null);

        // Configuration and runtime references
        this._config = {};
        this._hass = null;

        // Timeline update interval
        this.updateInterval = null;

        // UI elements
        this.tooltipElement = null;

        // Color and styling
        this._colors = {
            ...DEFAULT_COLORS
        };

        // Toggle lock to prevent rapid successive toggles
        this._isToggling = false;

        // Current time and selected day - REQUIRED for timeline display
        this.currentTime = this.getCurrentTime();
        this.selectedDay = this.currentTime.day;

        // PERFORMANCE FIX: Initialize block metrics cache for Issue #10
        this._blockMetricsCache = new Map();
    }

    getLanguage() {
        return this._langHelper.getLanguage();
    }

    t(key) {
        return this._langHelper.t(key);
    }

    /**
     * Translate condition text by applying all translation patterns sequentially
     * Patterns are applied in order to avoid conflicts (e.g., sunrise before sun)
     * Replace the old _translateConditionText method with this one
     * 
     * @param {string} text - Raw condition text to translate
     * @returns {string} Fully translated condition text
     */
    _translateConditionText(text) {
        if (!text) return "";

        let translated = text;

        // Apply all translation patterns in sequence
        for (const pattern of CONDITION_TRANSLATION_PATTERNS) {
            if (pattern.type === 'simple') {
                // Simple key translation: replace with t(key) + ":"
                const replacement = this.t(pattern.key) + ":";
                translated = translated.replace(pattern.pattern, replacement);
            } else if (pattern.type === 'template') {
                // Template translation: use function to generate replacement
                const replacement = pattern.template(this.t.bind(this));
                translated = translated.replace(pattern.pattern, replacement);
            } else if (pattern.type === 'labelSuffix') {
                // Label suffix: replace with t(key) + ":"
                const replacement = this.t(pattern.key) + ":";
                translated = translated.replace(pattern.pattern, replacement);
            } else if (pattern.type === 'operator') {
                // Operator: add spaces around translated operator
                const replacement = ` ${this.t(pattern.key)} `;
                translated = translated.replace(pattern.pattern, replacement);
            } else if (pattern.type === 'notOperator') {
                // NOT operator: no space after
                const replacement = `${this.t(pattern.key)} (`;
                translated = translated.replace(pattern.pattern, replacement);
            }
        }

        // Translate day abbreviations (after sunrise/sunset to avoid "Sun" conflicts)
        const dayTranslations = this.t("days");
        for (const [abbr, dayKey] of Object.entries(DAY_ABBREVIATION_MAP)) {
            const translatedDay = dayTranslations[dayKey];
            if (translatedDay) {
                // Use word boundary to avoid matching "Sun" in "Sunrise"
                translated = translated.replace(
                    new RegExp(`\\b${abbr}\\b`, 'g'),
                    translatedDay
                );
            }
        }

        return translated;
    }

    use12HourFormat() {
        return this._hass?.locale?.time_format === "12" || this.getLanguage() === "en";
    }

    formatHour(hour) {
        if (this.use12HourFormat()) {
            if (hour === 0) return "12 AM";
            if (hour < 12) return hour + " AM";
            if (hour === 12) return "12 PM";
            return hour - 12 + " PM";
        }
        return hour + "h";
    }

    setConfig(config) {
        /**
         * VALIDATION FIX: Comprehensive input validation
         * Prevents crashes from malformed configurations
         */
        if (!config || typeof config !== 'object') {
            throw new Error("Invalid configuration: config must be an object");
        }

        // Validate entities array
        let entities = config.entities || [];
        if (!Array.isArray(entities)) {
            throw new Error("Invalid configuration: entities must be an array");
        }

        const validatedEntities = entities
            .map((e, idx) => this._validateEntity(e, idx))
            .filter(e => e !== null);

        if (validatedEntities.length === 0 && entities.length > 0) {
            console.warn("Schedule State Card: No valid entities found in configuration");
        }

        // Validate colors
        const validatedColors = this._validateColors(config.colors);

        // Validate title
        const validatedTitle = this._validateTitle(config.title);

        this._config = {
            title: validatedTitle,
            entities: validatedEntities,
            show_state_in_title: config.show_state_in_title !== false,
            colors: validatedColors
        };

        // Apply color configuration
        this._colors = {
            ...DEFAULT_COLORS,
            ...this._config.colors
        };

        if (this._hass) this.render();
    }

    _validateEntity(entity, index) {
        /**
         * Validate a single entity configuration object
         * Returns validated entity or null if invalid
         */
        try {
            // Handle string entity IDs
            if (typeof entity === 'string') {
                const trimmedId = entity.trim();
                if (!trimmedId) {
                    console.warn(`Schedule State Card: Entity at index ${index} is empty`);
                    return null;
                }
                if (!trimmedId.includes('.')) {
                    console.warn(`Schedule State Card: Invalid entity ID format: "${trimmedId}"`);
                    return null;
                }
                return {
                    entity: trimmedId,
                    name: '',
                    icon: ''
                };
            }

            // Handle object entity configs
            if (typeof entity !== 'object' || entity === null) {
                console.warn(`Schedule State Card: Entity at index ${index} must be string or object`);
                return null;
            }

            const entityId = String(entity.entity || '').trim();
            if (!entityId) {
                console.warn(`Schedule State Card: Entity at index ${index} missing 'entity' field`);
                return null;
            }
            if (!entityId.includes('.')) {
                console.warn(`Schedule State Card: Invalid entity ID format: "${entityId}"`);
                return null;
            }

            return {
                entity: entityId,
                name: String(entity.name || '').trim().substring(0, 200),
                icon: String(entity.icon || '').trim().substring(0, 100)
            };
        } catch (error) {
            console.error(`Schedule State Card: Error validating entity at index ${index}:`, error);
            return null;
        }
    }

    _validateColors(colors) {
        /**
         * Validate color configuration
         * Returns valid colors or defaults
         * Accepts: hex colors, CSS variables, and color names
         */
        if (!colors || typeof colors !== 'object') {
            return {
                ...DEFAULT_COLORS
            };
        }

        const validated = {
            ...DEFAULT_COLORS
        };

        for (const [key, value] of Object.entries(colors)) {
            try {
                if (!value) continue;
                
                const strValue = String(value).trim();
                
                // Accept CSS variables (var(...))
                if (strValue.includes('var(')) {
                    validated[key] = strValue;
                    continue;
                }
                
                // Accept hex colors
                if (/^#[0-9A-F]{6}$/i.test(strValue)) {
                    validated[key] = strValue;
                    continue;
                }
                
                // Accept RGB/RGBA colors
                if (/^rgba?\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*(,\s*[\d.]+)?\s*\)$/.test(strValue)) {
                    validated[key] = strValue;
                    continue;
                }
                
                // Accept HSL/HSLA colors
                if (/^hsla?\(\s*\d+(\.\d+)?\s*,\s*\d+(\.\d+)?%\s*,\s*\d+(\.\d+)?%\s*(,\s*[\d.]+)?\s*\)$/.test(strValue)) {
                    validated[key] = strValue;
                    continue;
                }
                
                // If color format is invalid, use default
                console.warn(`Schedule State Card: Invalid color format for key "${key}": "${strValue}". Using default.`);
                
            } catch (error) {
                console.warn(`Schedule State Card: Error validating color for key "${key}":`, error);
            }
        }

        return validated;
    }

    _validateTitle(title) {
        /**
         * Validate card title
         * Limit length to prevent memory issues
         */
        if (!title) return '';

        try {
            const str = String(title).trim();
            // Limit title to 500 characters
            return str.substring(0, 500);
        } catch (error) {
            console.error("Schedule State Card: Error validating title:", error);
            return '';
        }
    }

    set hass(hass) {
        this._hass = hass;
        this._langHelper.setHass(hass);
        if (this._config?.entities && !this.shadowRoot.querySelector("ha-card")) {
            this.render();
        }

        // ✅ DEBOUNCE WITH CENTRALIZED STATE
        // Use state's timing tracking instead of local variable
        const now = Date.now();
        const timeSinceLastUpdate = this._state.getTimeSinceLastUpdate();

        if (timeSinceLastUpdate < 500) {
            // Schedule delayed update
            const newTimer = setTimeout(() => {
                this.updateContent();
                this._state.updateLastUpdateTime(Date.now());
            }, 500);

            // Store timer reference in centralized state
            this._state.setTimer('debounce', newTimer);
        } else {
            // Update immediately
            this.updateContent();
            this._state.updateLastUpdateTime(now);
        }
    }

    static getConfigElement() {
        return document.createElement("schedule-state-card-editor");
    }

    static getStubConfig() {
        return {
            entities: [{
                entity: "sensor.schedule_consigne_rdc",
                name: "RDC",
                icon: "mdi:thermometer"
            }],
            title: "Schedule Planning",
            colors: {
                ...DEFAULT_COLORS
            }
        };
    }

    getCardSize() {
        return 8;
    }

    getDays() {
        const dayTranslations = TRANSLATIONS[this.getLanguage()]?.days || TRANSLATIONS.en.days;
        return ["mon", "tue", "wed", "thu", "fri", "sat", "sun"].map(id => ({
            id,
            label: dayTranslations[id]
        }));
    }

    getCurrentTime() {
        const now = new Date();
        const dayMap = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
        return {
            day: dayMap[now.getDay()],
            hours: String(now.getHours()).padStart(2, "0"),
            minutes: String(now.getMinutes()).padStart(2, "0")
        };
    }

    isToday() {
        return this.selectedDay === this.currentTime.day;
    }

    /**
     * Updated getCurrentTimePercentage method
     * Replace the existing getCurrentTimePercentage method with this one
     */
    getCurrentTimePercentage() {
        return this._getTimePercentage(this.currentTime);
    }

    /**
     * Updated startTimelineUpdate method - use LAYOUT_CONSTANTS
     * Replace the existing startTimelineUpdate method with this one
     */
    startTimelineUpdate() {
        // Always stop existing interval first to prevent duplicates
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }

        // Create new interval using centralized constant
        this.updateInterval = setInterval(() => {
            this.currentTime = this.getCurrentTime();
            this.updateTimeline();
        }, LAYOUT_CONSTANTS.TIMELINE_UPDATE_INTERVAL_MS);
    }

    /**
     * Updated stopTimelineUpdate method
     * This is already correct but keep it as-is
     */
    stopTimelineUpdate() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
    }

    /**
     * Updated updateTimeline method
     * Replace the existing updateTimeline method with this one
     */
    updateTimeline() {
        const containers = this.shadowRoot.querySelectorAll(".timeline-container");

        if (!this.isToday()) {
            containers.forEach(container => {
                const cursor = container.querySelector(".time-cursor");
                if (cursor) cursor.style.display = "none";
            });
            return;
        }

        const timePercentage = this.getCurrentTimePercentage();
        this._updateTimelineCursors(timePercentage);
    }

    getPerceivedLuminance(h, s, l) {
        const c = (s / 100) * (1 - Math.abs(2 * (l / 100) - 1));
        const h_prime = h / 60;
        let r_prime, g_prime, b_prime;
        if (h_prime <= 1) {
            r_prime = c;
            g_prime = c * h_prime;
            b_prime = 0;
        } else if (h_prime <= 2) {
            r_prime = c * (2 - h_prime);
            g_prime = c;
            b_prime = 0;
        } else if (h_prime <= 3) {
            r_prime = 0;
            g_prime = c;
            b_prime = c * (h_prime - 2);
        } else if (h_prime <= 4) {
            r_prime = 0;
            g_prime = c * (4 - h_prime);
            b_prime = c;
        } else if (h_prime <= 5) {
            r_prime = c * (h_prime - 4);
            g_prime = 0;
            b_prime = c;
        } else {
            r_prime = c;
            g_prime = 0;
            b_prime = c * (6 - h_prime);
        }
        const m = (l / 100) - c / 2;
        const r = r_prime + m;
        const g = g_prime + m;
        const b = b_prime + m;
        const luminance = 0.2126 * (r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4)) +
            0.7152 * (g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4)) +
            0.0722 * (b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4));
        return luminance;
    }

    getTextColorForBackground(hslColor) {
        const match = hslColor.match(/hsl\((\d+(?:\.\d+)?),\s*(\d+(?:\.\d+)?)%,\s*(\d+(?:\.\d+)?)%\)/);
        if (!match) return "#000000";
        const h = parseFloat(match[1]);
        const s = parseFloat(match[2]);
        const l = parseFloat(match[3]);
        const luminance = this.getPerceivedLuminance(h, s, l);
        return luminance > 0.5 ? "#000000" : "#ffffff";
    }

    getColorForState(stateValue, unit) {
        const cacheKey = `${stateValue}|${unit}`;

        // ✅ USE CENTRALIZED COLOR CACHE
        if (this._state.caches.colors.has(cacheKey)) {
            return this._state.caches.colors.get(cacheKey);
        }

        // Calculate color (existing logic)
        let valueStr = String(stateValue === null || stateValue === undefined ? "" : stateValue).trim();
        const numMatch = valueStr.match(/^[\d.]+/);
        if (numMatch) valueStr = String(parseFloat(numMatch[0]));

        const unitStr = String(unit === null || unit === undefined ? "" : unit).trim();

        let str;
        if (unitStr) {
            str = valueStr ? `V:${valueStr}|U:${unitStr}` : `V:${unitStr}|U:${unitStr}`;
        } else {
            str = valueStr ? `V:${valueStr}` : "";
        }

        let hash = 2166136261;
        const prime = 16777619;
        for (let i = 0; i < str.length; i++) {
            hash ^= str.charCodeAt(i);
            hash = (hash * prime) >>> 0;
        }

        hash = (hash ^ (hash >>> 16)) >>> 0;
        hash = (Math.imul(hash, 0x85ebca6b)) >>> 0;
        hash = (hash ^ (hash >>> 13)) >>> 0;
        hash = (Math.imul(hash, 0xc2b2ae35)) >>> 0;
        hash = (hash ^ (hash >>> 16)) >>> 0;

        const goldenAngle = 137.507764;
        const hueOffset = hash * 0.1;
        const hue = ((hash * goldenAngle) + hueOffset) % 360;
        const sat = 50 + (hash % 40);
        const light = 35 + ((hash >>> 8) % 30);

        const hsl = `hsl(${hue.toFixed(1)}, ${sat}%, ${light}%)`;
        const textColor = this.getTextColorForBackground(hsl);

        const result = {
            color: hsl,
            textColor: textColor
        };

        // ✅ STORE IN CENTRALIZED COLOR CACHE
        this._state.caches.colors.set(cacheKey, result);

        return result;
    }

    /**
     * Convert HH:MM time string to minutes since midnight
     * Centralizes conversion to use consistent MINUTES_PER_DAY constant
     * Add this method to replace the old timeToMinutes method
     * 
     * @param {string} time - Time string in HH:MM format
     * @returns {number} Minutes since midnight (0-1440)
     */
    timeToMinutes(time) {
        if (!time || typeof time !== "string") return 0;
        const parts = time.split(":");
        if (parts.length < 2) return 0;

        const hours = parseInt(parts[0]) || 0;
        const minutes = parseInt(parts[1]) || 0;
        return hours * 60 + minutes;
    }

    /**
     * Calculate percentage of day elapsed
     * Centralizes time percentage calculation
     * Add this as a new helper method
     * 
     * @param {Object} timeObj - Object with hours and minutes
     * @returns {number} Percentage of day (0-100)
     */
    _getTimePercentage(timeObj) {
        if (!timeObj?.hours || !timeObj?.minutes) return 0;

        const hours = parseInt(timeObj.hours);
        const minutes = parseInt(timeObj.minutes);
        const totalMinutes = hours * 60 + minutes;

        return (totalMinutes / LAYOUT_CONSTANTS.MINUTES_PER_DAY) * 100;
    }

    /**
     * Validate and normalize time bounds for a block
     * Centralizes time validation logic
     * Add this as a new helper method
     * 
     * @param {Object} block - Block object with start and end times
     * @returns {Object} Normalized block with startMin and endMin
     */
    _normalizeBlockTimes(block) {
        let startMin = this.timeToMinutes(block.start);
        let endMin = this.timeToMinutes(block.end);

        // Handle day-wrapping blocks (end time is 00:00)
        if (block.end === "00:00" && endMin === 0) {
            endMin = LAYOUT_CONSTANTS.MINUTES_PER_DAY;
        }
        if (block.end === "23:59") {
            endMin = LAYOUT_CONSTANTS.MINUTES_PER_DAY;
        }

        return {
            startMin,
            endMin
        };
    }

    /**
     * Calculate block position and width as percentages
     * Centralizes block dimension calculations
     * Add this as a new helper method
     * 
     * @param {number} startMin - Start time in minutes
     * @param {number} endMin - End time in minutes
     * @returns {Object} Object with left and width percentages
     */
    _calculateBlockDimensions(startMin, endMin) {
        const left = (startMin / LAYOUT_CONSTANTS.MINUTES_PER_DAY) * 100;
        const width = ((endMin - startMin) / LAYOUT_CONSTANTS.MINUTES_PER_DAY) * 100;

        return {
            left,
            width
        };
    }

    /**
     * Determine border radius based on block position and type
     * Centralizes border radius logic
     * Add this as a new helper method
     * 
     * @param {number} width - Block width percentage
     * @param {number} startMin - Block start time in minutes
     * @param {number} endMin - Block end time in minutes
     * @param {boolean} isDefaultBg - Whether this is a default background block
     * @returns {string} CSS border-radius value
     */
    _calculateBorderRadius(width, startMin, endMin, isDefaultBg = false) {
        const MIN_PER_DAY = LAYOUT_CONSTANTS.MINUTES_PER_DAY;

        // Full-width blocks
        if (width === 100) {
            return isDefaultBg ? "0" : "4px";
        }

        // Wrapped blocks
        if (isDefaultBg) {
            if (startMin === 0 && endMin < MIN_PER_DAY) {
                return "0 4px 4px 0";
            } else if (startMin > 0 && endMin === MIN_PER_DAY) {
                return "4px 0 0 4px";
            }
            return "0";
        }

        // Regular blocks
        if (endMin <= startMin) {
            return "4px"; // Wrapped block
        } else if (startMin === 0) {
            return "0 4px 4px 0";
        } else if (endMin === MIN_PER_DAY) {
            return "4px 0 0 4px";
        }

        return "4px";
    }

    /**
     * Generate container height based on number of layers
     * Centralizes height calculation logic
     * Add this as a new helper method
     * 
     * @param {number} layerCount - Number of visible layers
     * @returns {number} Total container height in pixels
     */
    _calculateContainerHeight(layerCount) {
        const {
            BLOCK_HEIGHT,
            VERTICAL_GAP,
            TOP_MARGIN,
            BOTTOM_MARGIN
        } = LAYOUT_CONSTANTS;

        if (layerCount === 0) return TOP_MARGIN + BOTTOM_MARGIN;

        return TOP_MARGIN +
            layerCount * BLOCK_HEIGHT +
            (layerCount - 1) * VERTICAL_GAP +
            BOTTOM_MARGIN;
    }

    /**
     * Build CSS style string for a schedule block
     * Centralizes block styling logic
     * Add this as a new helper method
     * 
     * @param {Object} params - Style parameters object
     * @returns {string} CSS style string
     */
    _buildBlockStyle(params) {
        const {
            left,
            width,
            top,
            borderRadius,
            textColor,
            backgroundColor
        } = params;

        const validatedBgColor = this.validateStyleValue(backgroundColor);
        const validatedTextColor = this.validateStyleValue(textColor);

        return `left:${left}%;width:${width}%;top:${top}px;border-radius:${borderRadius};color:${validatedTextColor};background-color:${validatedBgColor};`;
    }

    /**
     * Generate tooltip text for a schedule block
     * Centralizes tooltip generation logic
     * Add this as a new helper method
     * 
     * @param {Object} params - Tooltip parameters object
     * @returns {string} Formatted tooltip text
     */
    _buildBlockTooltip(params) {
        const {
            block,
            isWrapped,
            isDynamic,
            isCombined,
            isDefault,
            escapedState,
            escapedUnit
        } = params;

        let tooltipText = this.t("time_label") + ": ";

        // Time portion
        if (isWrapped) {
            const originalStart = block.original_start || block.start;
            const originalEnd = block.original_end || block.end;
            tooltipText += `${originalStart} - ${originalEnd} (${this.t("wrapping")})`;
        } else {
            tooltipText += `${block.start} - ${block.end}`;
        }

        // State portion
        tooltipText += `\n🌡️ ${this.t("state_label")}: ${escapedState}`;
        if (escapedUnit) tooltipText += ` ${escapedUnit}`;

        // Layer source
        if (isCombined) {
            tooltipText += `\n(${this.t("cond_combined_result")})`;
        } else if (isDefault) {
            tooltipText += `\n(${this.t("default_state_label")})`;
        }

        // Dynamic value reference
        if (isDynamic) {
            const entity = this.extractEntityFromTemplate(block.raw_state_template || block.state_value);
            const blockIcon = block.icon || "mdi:calendar";

            if (blockIcon === "mdi:refresh") {
                const refText = entity ? ` (${this.t("dynamic_ref_schedule")}: ${escapeHtml(entity)})` : "";
                tooltipText += `\n🔄 ${this.t("dynamic_value")}${refText}`;
            } else {
                const refText = entity ? ` (${this.t("dynamic_ref_sensor")}: ${escapeHtml(entity)})` : "";
                tooltipText += `\n📊 ${this.t("dynamic_value")}${refText}`;
            }
        }

        // Block description
        if (block.description) {
            tooltipText += `\n💬 ${escapeHtml(block.description)}`;
        }

        return tooltipText;
    }

    sanitizeUrl(url) {
        // Handle empty/null
        if (!url) return "";

        const str = String(url).trim().toLowerCase();

        // Block dangerous protocols
        if (str.startsWith("javascript:") ||
            str.startsWith("data:") ||
            str.startsWith("vbscript:") ||
            str.startsWith("file:")) {
            console.warn("Blocked unsafe URL protocol:", url);
            return "";
        }

        // Allow safe URLs
        if (str.startsWith("http://") ||
            str.startsWith("https://") ||
            str.startsWith("/") ||
            str.startsWith("./") ||
            str.startsWith("../")) {
            return url;
        }

        // Default: allow if no protocol (relative URLs)
        return url;
    }

    createSafeElement(tagName, attributes = {}, textContent = "") {
        // Create the element
        const element = document.createElement(tagName);

        // Set attributes safely
        for (const [key, value] of Object.entries(attributes)) {
            // Skip dangerous attributes
            if (key.toLowerCase().startsWith("on")) {
                console.warn("Blocked event handler attribute:", key);
                continue;
            }

            // Sanitize URLs in href/src
            if (key.toLowerCase() === "href" || key.toLowerCase() === "src") {
                const sanitized = this.sanitizeUrl(value);
                if (sanitized) {
                    element.setAttribute(key, sanitized);
                }
                continue;
            }

            // Set other attributes
            element.setAttribute(key, String(value));
        }

        // Set text content (NOT innerHTML) to prevent XSS
        if (textContent) {
            element.textContent = textContent;
        }

        return element;
    }

    /**
     * Generate CSS style string for layer icon
     * Centralizes icon styling logic
     * Add this as a new helper method
     * 
     * @param {Object} params - Icon style parameters object
     * @returns {string} CSS style string
     */
    _buildIconStyle(params) {
        const {
            isActive,
            isCombined,
            isUnfolded,
            isSelectedDayToday
        } = params;

        let bgColor;
        let filter = "filter:brightness(1.1);";

        if (isCombined) {
            bgColor = isUnfolded ?
                this._colors.combined_unfolded_layer :
                this._colors.combined_folded_layer;
            filter = isUnfolded ? "filter:brightness(1.3);" : "filter:brightness(1.1);";
        } else {
            bgColor = isActive ?
                this._colors.active_layer :
                this._colors.inactive_layer;
            filter = isActive ? "filter:brightness(1.3);" : "";
        }

        const opacity = !isSelectedDayToday ? "opacity:0.5;" : "";
        const brightnessAdjust = !isSelectedDayToday ? "filter:brightness(0.8);" : filter;

        return `background:${bgColor};${opacity}${brightnessAdjust}`;
    }

    /**
     * Update timeline cursor position if today is selected
     * Centralizes cursor update logic with bounds checking
     * Add this as a new helper method
     * 
     * @param {number} timePercentage - Current time as percentage of day
     */
    _updateTimelineCursors(timePercentage) {
        if (!this.isToday()) {
            // Hide all cursors if not today
            this.shadowRoot?.querySelectorAll(".time-cursor").forEach(cursor => {
                cursor.style.display = "none";
            });
            return;
        }

        // Show and position cursors
        const containers = this.shadowRoot?.querySelectorAll(".timeline-container");
        if (!containers) return;

        containers.forEach(container => {
            let cursor = container.querySelector(".time-cursor");

            if (!cursor) {
                cursor = document.createElement("div");
                cursor.className = "time-cursor";
                container.appendChild(cursor);
            }

            cursor.style.display = "block";
            cursor.style.left = timePercentage + "%";
            cursor.style.backgroundColor = this._colors.cursor;
        });
    }

    validateStyleValue(value) {
        /**
         * SECURITY FIX: Whitelist approach for CSS values
         * Prevents CSS injection attacks
         * Now accepts CSS variables with proper validation
         */
        if (!value) return "";

        const original = String(value).trim();
        const lower = original.toLowerCase();

        // Allow CSS variables (they're safe when properly formed)
        if (/^var\(--[a-z0-9-]+(\s*,\s*#[0-9a-f]{6}|rgba?\([^)]+\)|hsla?\([^)]+\))?\)$/i.test(original)) {
            return original;
        }

        // Blacklist: Reject dangerous patterns
        const dangerousPatterns = [
            "expression(",
            "javascript:",
            "behavior:",
            "binding(",
            "@import",
            "-webkit-binding",
        ];

        for (const pattern of dangerousPatterns) {
            if (lower.includes(pattern)) {
                console.warn("CSS validation: Blocked dangerous CSS pattern:", pattern);
                return "";
            }
        }

        // Whitelist: Accept known safe formats

        // HSL color format
        if (/^hsl\(\s*\d+(\.\d+)?\s*,\s*\d+(\.\d+)?%\s*,\s*\d+(\.\d+)?%\s*\)$/.test(original)) {
            return original;
        }

        // Hex color format
        if (/^#[0-9A-F]{6}$/i.test(original)) {
            return original;
        }

        // RGB/RGBA color format
        if (/^rgba?\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*(,\s*[\d.]+)?\s*\)$/.test(original)) {
            return original;
        }

        // Pixel/em/rem/percent units
        if (/^\d+(\.\d+)?(px|em|rem|%|vh|vw|ch)$/i.test(original)) {
            return original;
        }

        // Plain numbers (for opacity, etc)
        if (/^\d+(\.\d+)?$/.test(original)) {
            return original;
        }

        // If not in whitelist, reject
        console.warn("CSS validation: Rejected non-whitelisted CSS value:", value);
        return "";
    }

    decodeHtmlEntities(text) {
        const map = {
            "&amp;": "&",
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&#39;": "'"
        };
        return String(text).replace(/&amp;|&lt;|&gt;|&quot;|&#39;/g, m => map[m]);
    }

    truncateText(text, maxWidthPx) {
        if (!text || typeof text !== "string") return text;
        if (maxWidthPx < 30) return "...";

        const charWidth = 6;
        const maxChars = Math.floor(maxWidthPx / charWidth) - 2;

        if (maxChars <= 0) return "...";
        if (text.length <= maxChars) return text;

        // Return truncated text (caller will escape)
        return text.substring(0, maxChars) + "...";
    }

    resolveTemplate(template) {
        if (!template || typeof template !== "string") return template;
        if (!this._hass) return template;
        let result = template.trim();
        result = result.replace(/\{\{|\}\}/g, "").replace(/\{%|%\}/g, "").trim();
        const ifElifMatch = result.match(/if\s+(.+?)\s+(.+?)\s+elif\s+(.+?)\s+(.+?)\s+else\s+(.+?)$/is);
        if (ifElifMatch) {
            result = this.evalCondition(ifElifMatch[1].trim()) ? ifElifMatch[2].trim() : this.evalCondition(ifElifMatch[3].trim()) ? ifElifMatch[4].trim() : ifElifMatch[5].trim();
        } else {
            const ifMatch = result.match(/if\s+(.+?)\s+(.+?)\s+else\s+(.+?)$/is);
            if (ifMatch) result = this.evalCondition(ifMatch[1].trim()) ? ifMatch[2].trim() : ifMatch[3].trim();
        }
        result = result.replace(/states\(\s*['"]([^'"]+)['"]\s*\)/g, (match, entity) => {
            const state = this._hass.states[entity];
            return state ? String(state.state) : "0";
        });
        result = result.replace(/state_attr\(\s*['"]([^'"]+)['"]\s*,\s*['"]([^'"]+)['"]\s*\)/g, (match, entity, attr) => {
            const state = this._hass.states[entity];
            return state?.attributes?.[attr] !== undefined ? String(state.attributes[attr]) : "0";
        });
        result = result.replace(/\|\s*float\([^)]*\)/g, "").replace(/\|\s*int\([^)]*\)/g, "").replace(/\|\s*float\b/g, "").replace(/\|\s*int\b/g, "");
        result = this._evalMath(result);
        return String(result).trim();
    }

    _clearCaches() {
        this._colorCache.clear();
        this._domCache = null;
    }

    getCachedDOMMetrics() {
        // Get from centralized cache
        let metrics = this._state.getDOMMetrics();

        if (metrics) {
            return metrics;
        }

        // Calculate metrics if not cached
        const container = this.shadowRoot.querySelector(".timeline-container");

        // Safety check: if container doesn't exist, use default width
        if (!container) {
            console.warn("Timeline container not found, using default width");
            metrics = {
                containerWidth: 800
            };
        } else {
            // Get actual container width from DOM
            const containerWidth = container.offsetWidth || 800;
            metrics = {
                containerWidth
            };
        }

        // Store in centralized cache
        this._state.setDOMMetrics(metrics);

        return metrics;
    }

    invalidateDOMMetrics() {
        // ✅ INVALIDATE CENTRALIZED CACHE
        this._state.invalidateDOMCache();
    }

    _evalMath(expr) {
        if (!expr || typeof expr !== 'string') return String(expr);
        let cleanedExpr = expr.trim();
        if (!/^[\d\s\.\+\-\*\/\(\)]+$/.test(cleanedExpr)) {
            const num = parseFloat(cleanedExpr);
            return isNaN(num) ? expr : String(num);
        }
        try {
            const result = this._safeMathEval(cleanedExpr);
            if (typeof result === 'number' && !isNaN(result)) return String(result);
            return expr;
        } catch (e) {
            console.error("Schedule card: Math eval failed:", cleanedExpr, e);
            return expr;
        }
    }

    _safeMathEval(expr) {
        const tokens = [];
        let current = '';
        for (let i = 0; i < expr.length; i++) {
            const char = expr[i];
            if ('+-*/()'.includes(char)) {
                if (current) tokens.push(parseFloat(current));
                tokens.push(char);
                current = '';
            } else if (char === ' ') {
                if (current) tokens.push(parseFloat(current));
                current = '';
            } else {
                current += char;
            }
        }
        if (current) tokens.push(parseFloat(current));
        return this._evaluateTokens(tokens);
    }

    _evaluateTokens(tokens) {
        while (tokens.includes('(')) {
            const startIdx = tokens.lastIndexOf('(');
            let endIdx = tokens.indexOf(')', startIdx);
            if (endIdx === -1) throw new Error('Mismatched parentheses');
            const subTokens = tokens.slice(startIdx + 1, endIdx);
            const result = this._evaluateTokens(subTokens);
            tokens.splice(startIdx, endIdx - startIdx + 1, result);
        }
        for (let i = 1; i < tokens.length; i += 2) {
            if (tokens[i] === '*') {
                const result = tokens[i - 1] * tokens[i + 1];
                tokens.splice(i - 1, 3, result);
                i -= 2;
            } else if (tokens[i] === '/') {
                if (tokens[i + 1] === 0) throw new Error('Division by zero');
                const result = tokens[i - 1] / tokens[i + 1];
                tokens.splice(i - 1, 3, result);
                i -= 2;
            }
        }
        for (let i = 1; i < tokens.length; i += 2) {
            if (tokens[i] === '+') {
                const result = tokens[i - 1] + tokens[i + 1];
                tokens.splice(i - 1, 3, result);
                i -= 2;
            } else if (tokens[i] === '-') {
                const result = tokens[i - 1] - tokens[i + 1];
                tokens.splice(i - 1, 3, result);
                i -= 2;
            }
        }
        return tokens[0];
    }

    evalCondition(condition) {
        let expr = condition.trim();
        expr = expr.replace(/is_state\(\s*['"]([^'"]+)['"]\s*,\s*['"]([^'"]+)['"]\s*\)/g, (match, entity, value) => {
            const state = this._hass.states[entity];
            return state && state.state === value ? "true" : "false";
        });
        expr = expr.replace(/\band(s*)\b/gi, "&&").replace(/\bor\b/gi, "||").replace(/\bnot\b/gi, "!");
        return this._safeBooleanEval(expr);
    }

    _safeBooleanEval(expr) {
        expr = expr.trim().replace(/\bfalse\b/g, "0").replace(/\btrue\b/g, "1");
        try {
            if (!/^[01&|()!\s]+$/.test(expr)) return false;
            let result = expr;
            while (result.includes("!")) result = result.replace(/!([01])/g, (m, v) => v === "1" ? "0" : "1");
            while (result.includes("&&")) result = result.replace(/([01])\s*&&\s*([01])/g, (m, a, b) => (a === "1" && b === "1") ? "1" : "0");
            while (result.includes("||")) result = result.replace(/([01])\s*\|\|\s*([01])/g, (m, a, b) => (a === "1" || b === "1") ? "1" : "0");
            return result.replace(/\s/g, "") === "1";
        } catch (e) {
            console.error("Schedule card: condition evaluation failed", e);
            return false;
        }
    }

    _evaluateConditionsForLayer(layer) {
        // Don't evaluate default layers
        if (layer.is_default_layer) return false;
        // Don't evaluate combined layers themselves
        if (layer.is_combined_layer) return false;
        // If no blocks, consider it active
        if (!layer?.blocks?.length) return true;

        // Collect all conditions from all blocks in this layer
        let allConditions = [];
        for (const block of layer.blocks) {
            if (block.raw_conditions?.length) {
                allConditions = allConditions.concat(block.raw_conditions);
            }
        }
        // If no conditions, the layer is active
        if (allConditions.length === 0) return true;

        // Remove duplicate conditions
        const conditionStrings = new Set();
        const uniqueConditions = [];
        for (const cond of allConditions) {
            const condStr = JSON.stringify(cond);
            if (!conditionStrings.has(condStr)) {
                conditionStrings.add(condStr);
                uniqueConditions.push(cond);
            }
        }

        // All conditions must be met for the layer to be active (AND logic)
        for (const cond of uniqueConditions) {
            // Evaluate all conditions - treating selected day as the "current day" for condition evaluation
            if (!this._evaluateCondition(cond)) return false;
        }
        return true;
    }

    _evaluateCondition(condition) {
        /**
         * ERROR HANDLING FIX: Comprehensive error handling
         * Prevents crashes when Home Assistant data is unavailable
         */
        try {
            if (!condition || typeof condition !== "object") return true;

            // Safety check: ensure Home Assistant is available
            if (!this._hass) {
                console.warn("Home Assistant state unavailable during condition evaluation");
                return false;
            }

            const condType = condition.condition;

            if (condType === "time") {
                const today = new Date();
                const currentMonth = today.getMonth() + 1;
                const selectedDayValue = this.selectedDay;

                if (condition.month !== undefined && condition.month !== null) {
                    const months = condition.month;
                    if (Array.isArray(months)) {
                        if (!months.includes(currentMonth)) return false;
                    } else if (typeof months === "number") {
                        if (currentMonth !== months) return false;
                    }
                }

                if (condition.weekday !== undefined && condition.weekday !== null) {
                    const weekdays = condition.weekday;
                    if (Array.isArray(weekdays)) {
                        if (!weekdays.includes(selectedDayValue)) return false;
                    }
                }

                return true;
            }

            if (condType === "state") {
                const entityId = condition.entity_id;
                if (!entityId) {
                    console.warn("State condition missing entity_id");
                    return false;
                }

                // Ensure states object exists
                if (!this._hass.states || typeof this._hass.states !== 'object') {
                    console.warn("Home Assistant states object unavailable");
                    return false;
                }

                const entities = Array.isArray(entityId) ? entityId : [entityId];

                if (condition.match === "all") {
                    return entities.every(id => {
                        try {
                            const entity = this._hass.states[id];
                            if (!entity) return false;
                            return entity.state === condition.state;
                        } catch (e) {
                            console.warn("Error checking entity state:", id, e);
                            return false;
                        }
                    });
                }

                return entities.some(id => {
                    try {
                        const entity = this._hass.states[id];
                        if (!entity) return false;
                        return entity.state === condition.state;
                    } catch (e) {
                        console.warn("Error checking entity state:", id, e);
                        return false;
                    }
                });
            }

            if (condType === "numeric_state") {
                const entityId = condition.entity_id;
                if (!entityId) {
                    console.warn("Numeric state condition missing entity_id");
                    return false;
                }

                if (!this._hass.states || typeof this._hass.states !== 'object') {
                    console.warn("Home Assistant states object unavailable");
                    return false;
                }

                const entities = Array.isArray(entityId) ? entityId : [entityId];

                return entities.some(id => {
                    try {
                        const entity = this._hass.states[id];
                        if (!entity) return false;

                        const value = parseFloat(entity.state);
                        if (isNaN(value)) return false;

                        if (condition.above !== undefined && value <= condition.above) return false;
                        if (condition.below !== undefined && value >= condition.below) return false;

                        return true;
                    } catch (e) {
                        console.warn("Error checking numeric state:", id, e);
                        return false;
                    }
                });
            }

            if (condType === "or") {
                if (!condition.conditions || !Array.isArray(condition.conditions)) return true;
                return condition.conditions.some(subCond => this._evaluateCondition(subCond));
            }

            if (condType === "and") {
                if (!condition.conditions || !Array.isArray(condition.conditions)) return true;
                return condition.conditions.every(subCond => this._evaluateCondition(subCond));
            }

            if (condType === "not") {
                if (!condition.conditions || !Array.isArray(condition.conditions)) return true;
                return !this._evaluateCondition(condition.conditions[0]);
            }

            return true;
        } catch (error) {
            console.error("Fatal error evaluating condition:", error, condition);
            return false;
        }
    }

    createCombinedLayer(defaultLayer, activeConditionalLayers) {
        /**
         * REFACTORING: Break down into smaller, focused methods
         * Each method has a single responsibility and is testable
         */
        if (!defaultLayer) return null;

        // Step 1: Collect and filter blocks
        const blocks = this._collectAndFilterBlocksForCombined(
            defaultLayer,
            activeConditionalLayers
        );

        // Step 2: Sort blocks by priority and time
        const sorted = this._sortCombinedBlocks(
            blocks,
            defaultLayer,
            activeConditionalLayers
        );

        // Step 3: Fill gaps with default layer
        const filled = this._fillGapsWithDefaultLayer(sorted, defaultLayer, activeConditionalLayers);

        return {
            is_combined_layer: true,
            condition_text: this.t("cond_combined_result"),
            is_default_layer: false,
            blocks: filled,
        };
    }

    _getBlockMetrics(block) {
        /**
         * PERFORMANCE FIX: Cache block time metrics
         * Avoid redundant parsing of time strings
         * 
         * Key format: "start|end" for memoization
         */
        // Create cache if not exists
        if (!this._blockMetricsCache) {
            this._blockMetricsCache = new Map();
        }

        const cacheKey = `${block.start}|${block.end}`;

        // Return cached result if available
        if (this._blockMetricsCache.has(cacheKey)) {
            return this._blockMetricsCache.get(cacheKey);
        }

        // Calculate metrics only once per unique time range
        const startMin = this.timeToMinutes(block.start);
        let endMin = this.timeToMinutes(block.end);

        if (block.end === "00:00" && endMin === 0) {
            endMin = LAYOUT_CONSTANTS.MINUTES_PER_DAY;
        }
        if (block.end === "23:59") {
            endMin = LAYOUT_CONSTANTS.MINUTES_PER_DAY;
        }

        const dimensions = this._calculateBlockDimensions(startMin, endMin);
        const borderRadius = this._calculateBorderRadius(
            dimensions.width,
            startMin,
            endMin,
            block.is_default_bg
        );

        const metrics = {
            startMin,
            endMin,
            dimensions,
            borderRadius
        };

        // Store in cache for future lookups
        this._blockMetricsCache.set(cacheKey, metrics);

        return metrics;
    }

    _sortCombinedBlocks(blocks, defaultLayer, activeConditionalLayers) {
        /**
         * Sort blocks by: layer priority, then start time, then event_idx
         */
        return blocks.sort((a, b) => {
            const layerIdxA = activeConditionalLayers.indexOf(a._source_layer);
            const layerIdxB = activeConditionalLayers.indexOf(b._source_layer);

            const isADefault = a._source_layer === defaultLayer;
            const isBDefault = b._source_layer === defaultLayer;

            // Conditional layers have higher priority than default
            if (isADefault && !isBDefault) return 1;
            if (!isADefault && isBDefault) return -1;

            // Same layer type: sort by start time
            const startA = this.timeToMinutes(a.start);
            const startB = this.timeToMinutes(b.start);
            if (startA !== startB) return startA - startB;

            // Same time: sort by event_idx (higher first)
            const idxA = a.event_idx !== undefined ? a.event_idx : -1;
            const idxB = b.event_idx !== undefined ? b.event_idx : -1;
            return idxB - idxA;
        });
    }

    _collectAndFilterBlocksForCombined(defaultLayer, activeConditionalLayers) {
        /**
         * Collect all blocks from active layers and filter by selected day
         */
        const result = [];

        for (const activeLayer of activeConditionalLayers) {
            if (!activeLayer.blocks) continue;

            for (const activeBlock of activeLayer.blocks) {
                if (this._blockAppliesToSelectedDay(activeBlock)) {
                    result.push({
                        ...activeBlock,
                        _source_layer: activeLayer
                    });
                }
            }
        }

        // Add default layer blocks at the end
        if (defaultLayer.blocks) {
            for (const defBlock of defaultLayer.blocks) {
                result.push({
                    ...defBlock,
                    _source_layer: defaultLayer
                });
            }
        }

        return result;
    }

    _blockAppliesToSelectedDay(block) {
        /**
         * Check if a block applies to the currently selected day
         */
        if (!block.raw_conditions || block.raw_conditions.length === 0) {
            return true;
        }

        for (const cond of block.raw_conditions) {
            if (cond.condition === "time" && cond.weekday && Array.isArray(cond.weekday)) {
                if (!cond.weekday.includes(this.selectedDay)) {
                    return false;
                }
            }
        }

        return true;
    }

    _fillGapsWithDefaultLayer(layerBlocks, defaultLayer, activeConditionalLayers) {
        /**
         * Fill time gaps between conditional blocks with default layer blocks
         * Maintains seamless coverage throughout the day
         */
        if (!layerBlocks || layerBlocks.length === 0) {
            return (defaultLayer.blocks || []).map(b => ({
                ...b,
                _source_layer: defaultLayer
            }));
        }

        const result = [];
        const breakpoints = new Set([0, 1440]);

        // Collect breakpoints from conditional blocks
        for (const layer of activeConditionalLayers) {
            for (const block of layerBlocks) {
                if (block._source_layer !== layer) continue;

                const startMin = this.timeToMinutes(block.start);
                let endMin = this.timeToMinutes(block.end);
                if (block.end === '00:00' && endMin === 0) endMin = 1440;

                breakpoints.add(startMin);
                breakpoints.add(endMin);
            }
        }

        // Collect breakpoints from default layer
        const defaultBlocks = defaultLayer.blocks || [];
        for (const defBlock of defaultBlocks) {
            const defStart = this.timeToMinutes(defBlock.start);
            let defEnd = this.timeToMinutes(defBlock.end);
            if (defBlock.end === '00:00' && defEnd === 0) defEnd = 1440;

            breakpoints.add(defStart);
            breakpoints.add(defEnd);
        }

        const sortedBreakpoints = Array.from(breakpoints).sort((a, b) => a - b);

        // Process each segment between breakpoints
        for (let i = 0; i < sortedBreakpoints.length - 1; i++) {
            const segStart = sortedBreakpoints[i];
            const segEnd = sortedBreakpoints[i + 1];

            // Find conditional blocks covering this segment
            let coveringBlocks = [];
            for (const block of layerBlocks) {
                if (block._source_layer === defaultLayer) continue;

                const blockStart = this.timeToMinutes(block.start);
                let blockEnd = this.timeToMinutes(block.end);
                if (block.end === '00:00' && blockEnd === 0) blockEnd = 1440;

                if (blockStart <= segStart && segEnd <= blockEnd) {
                    coveringBlocks.push(block);
                }
            }

            if (coveringBlocks.length > 0) {
                // Sort by layer priority
                coveringBlocks.sort((a, b) => {
                    const layerIdxA = activeConditionalLayers.indexOf(a._source_layer);
                    const layerIdxB = activeConditionalLayers.indexOf(b._source_layer);

                    if (layerIdxA !== layerIdxB) {
                        return layerIdxB - layerIdxA;
                    }

                    const aIdx = a.event_idx !== undefined ? a.event_idx : -1;
                    const bIdx = b.event_idx !== undefined ? b.event_idx : -1;
                    return bIdx - aIdx;
                });

                const coveringBlock = coveringBlocks[0];
                const segStartStr = this._minutesToTime(segStart);
                const segEndStr = segEnd === 1440 ? '00:00' : this._minutesToTime(segEnd);

                result.push({
                    ...coveringBlock,
                    start: segStartStr,
                    end: segEndStr,
                    is_default_bg: false
                });
            } else {
                // Use default layer for this segment
                for (const defBlock of defaultBlocks) {
                    const defStart = this.timeToMinutes(defBlock.start);
                    let defEnd = this.timeToMinutes(defBlock.end);
                    if (defBlock.end === '00:00' && defEnd === 0) defEnd = 1440;

                    if (defStart <= segStart && segEnd <= defEnd) {
                        const segStartStr = this._minutesToTime(segStart);
                        const segEndStr = segEnd === 1440 ? '00:00' : this._minutesToTime(segEnd);

                        result.push({
                            ...defBlock,
                            start: segStartStr,
                            end: segEndStr,
                            _source_layer: defaultLayer,
                            is_default_bg: true
                        });
                        break;
                    }
                }
            }
        }

        return result;
    }

    /**
     * Format a time value in minutes to HH:MM format
     * Centralizes time formatting to ensure consistency
     * @param {number} minutes - Minutes since midnight
     * @returns {string} Time formatted as HH:MM
     */
    _minutesToTime(minutes) {
        const hours = Math.floor(minutes / 60) % 24;
        const mins = minutes % 60;
        return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;
    }

    isDynamicTemplate(rawTemplate) {
        if (!rawTemplate || typeof rawTemplate !== "string") return false;
        return rawTemplate.includes("states(") || rawTemplate.includes("state_attr(") || rawTemplate.includes("{%") || rawTemplate.includes("{{");
    }

    isScheduleStateSensor(rawTemplate) {
        if (!rawTemplate || typeof rawTemplate !== "string" || !this._hass) return false;
        const match = rawTemplate.match(/(?:states|state_attr)\(\s*['"]([^'"]+)['"]/);
        if (!match) return false;
        const entityId = match[1];
        const entity = this._hass.states[entityId];
        if (!entity) return false;
        return entity.attributes?.icon === "mdi:calendar-clock";
    }

    extractEntityFromTemplate(template) {
        if (!template || typeof template !== "string") return "";
        const match = template.match(/(?:states|state_attr)\(\s*['"]([^'"]+)['"]/);
        return match ? match[1] : "";
    }

    ensureTooltipElement() {
        // MEMORY FIX: Attach tooltip to shadowRoot instead of document.body
        // This ensures automatic cleanup when the component disconnects
        if (!this.tooltipElement) {
            this.tooltipElement = document.createElement("div");
            this.tooltipElement.className = "custom-tooltip";

            this.tooltipElement.style.cssText = `
                position:fixed;
                background:var(--primary-background-color,#1a1a1a);
                color:var(--primary-text-color,white);
                padding:8px 12px;
                border-radius:4px;
                border:1px solid var(--divider-color,#333);
                font-size:12px;
                z-index:3;
                max-width:300px;
                word-wrap:break-word;
                box-shadow:0 2px 8px rgba(0,0,0,0.3);
                pointer-events:none;
                white-space:pre-line;
                display:none;
            `;

            // CHANGED: Append to shadowRoot instead of document.body
            this.shadowRoot.appendChild(this.tooltipElement);
        }

        return this.tooltipElement;
    }

    colorizeParentheses(text) {
        let result = "";
        let depth = 0;

        for (let i = 0; i < text.length; i++) {
            const char = text[i];

            if (char === "(") {
                const hue = (depth * 60) % 360;
                // Validate hue value to prevent CSS injection
                const safeHue = this.validateStyleValue(String(hue));
                const color = `hsl(${safeHue}, 80%, 70%)`;

                // Use single quotes for style attribute to avoid double escaping issues
                result += `<span style='color:${this.validateStyleValue(color)};font-weight:bold;'>(</span>`;
                depth++;
            } else if (char === ")") {
                depth = Math.max(0, depth - 1);
                const hue = (depth * 60) % 360;
                // Validate hue value to prevent CSS injection
                const safeHue = this.validateStyleValue(String(hue));
                const color = `hsl(${safeHue}, 80%, 70%)`;

                // Use single quotes for style attribute
                result += `<span style='color:${this.validateStyleValue(color)};font-weight:bold;'>)</span>`;
            } else if (char === "<") {
                result += "&lt;";
            } else if (char === ">") {
                result += "&gt;";
            } else if (char === "&") {
                result += "&amp;";
            } else if (char === '"') {
                result += "&quot;";
            } else if (char === "'") {
                result += "&#39;";
            } else if (char === "\n") {
                result += "<br>";
            } else {
                result += char;
            }
        }

        return result;
    }

    showTooltip(event, text) {
        const tooltip = this.ensureTooltipElement();

        // SECURITY FIX: Use textContent instead of innerHTML to prevent XSS
        // This eliminates all HTML/script injection vectors since no HTML parsing occurs
        const decoded = this.decodeHtmlEntities(text);
        const textWithNewlines = decoded.replace(/\\n/g, "\n");

        tooltip.textContent = textWithNewlines;

        const x = event.clientX;
        const y = event.clientY;
        const tooltipRect = tooltip.getBoundingClientRect();

        let top = y - tooltipRect.height - LAYOUT_CONSTANTS.TOOLTIP_OFFSET_Y;
        if (top < 0) top = y + LAYOUT_CONSTANTS.TOOLTIP_OFFSET_Y;

        let left = x + 15;
        if (left + tooltipRect.width > window.innerWidth - LAYOUT_CONSTANTS.TOOLTIP_MARGIN_X) {
            left = window.innerWidth - tooltipRect.width - LAYOUT_CONSTANTS.TOOLTIP_MARGIN_X;
        }

        if (typeof left === "number" && isFinite(left)) {
            tooltip.style.left = left + "px";
        }
        if (typeof top === "number" && isFinite(top)) {
            tooltip.style.top = top + "px";
        }

        tooltip.style.display = "block";
    }

    hideTooltip() {
        if (this.tooltipElement) {
            this.tooltipElement.style.display = "none";
        }
    }

    clearTooltipTimer() {
        // ✅ USE CENTRALIZED STATE for timer management
        this._state.clearTimer('tooltip');
    }

    toggleLayerVisibility(entityId) {
        if (this._isToggling) return;

        this._isToggling = true;

        // Use centralized state API
        this._state.toggleLayerVisibility(entityId);

        this.updateContent();

        setTimeout(() => {
            this._isToggling = false;
        }, 300);
    }

    /**
     * Updated scheduleTooltipDisplay method - use LAYOUT_CONSTANTS
     * Replace the existing scheduleTooltipDisplay method with this one
     */
    scheduleTooltipDisplay(event, text) {
        // Clear any pending tooltip timer
        this.clearTooltipTimer();

        // Schedule new tooltip with stabilization delay
        const timerId = setTimeout(() => {
            this.showTooltip(event, text);
        }, LAYOUT_CONSTANTS.MOUSE_STABILIZATION_DELAY);

        // Store timer reference in centralized state
        this._state.setTimer('tooltip', timerId);
    }

    fireEvent(node, type, detail = {}, options = {}) {
        // Fire custom event using Home Assistant pattern (CSP compliant)
        const event = new Event(type, {
            bubbles: options.bubbles || true,
            cancelable: options.cancelable || true,
            composed: options.composed || true,
        });
        event.detail = detail;
        node.dispatchEvent(event);
    }

    attachAllListeners() {
        const container = this.shadowRoot.querySelector("#content");

        if (!container) return;

        // Remove old listener if it exists (CRITICAL: prevents memory leaks)
        if (this._state.eventListener) {
            container.removeEventListener("click", this._state.eventListener);
            container.removeEventListener("mouseover", this._state.eventListener);
            container.removeEventListener("mouseout", this._state.eventListener);
        }

        // Define unified event handler
        const handler = (e) => {
            // Room name click - open entity info dialog
            const roomNameTarget = e.target.closest(".room-name");
            if (e.type === "click" && roomNameTarget) {
                const entityId = roomNameTarget.dataset.entityId;
                if (entityId && this._hass) {
                    this.fireEvent(this, 'hass-more-info', {
                        entityId: entityId
                    });
                }
                e.stopPropagation();
                e.preventDefault();
                return;
            }

            // Combined layer toggle click
            const toggleTarget = e.target.closest(".combined-layer-toggle");
            if (e.type === "click" && toggleTarget) {
                this.clearTooltipTimer();
                this.hideTooltip();
                const entityId = toggleTarget.dataset.entityId;
                if (entityId) {
                    this.toggleLayerVisibility(entityId);
                }
                e.stopPropagation();
                return;
            }

            // Tooltip hover display
            const tooltipTarget = e.target.closest(".schedule-block, .icon-row[data-tooltip]");

            if (e.type === "mouseover" && tooltipTarget) {
                const tooltip = tooltipTarget.dataset.tooltip;
                this.clearTooltipTimer();

                if (tooltip) {
                    const eventData = {
                        clientX: e.clientX,
                        clientY: e.clientY
                    };
                    this.scheduleTooltipDisplay(eventData, tooltip);
                }
            }
            // Tooltip hide on mouse leave
            else if (e.type === "mouseout") {
                this.clearTooltipTimer();
                setTimeout(() => this.hideTooltip(), 50);
            }
        };

        // Attach handler to all events
        container.addEventListener("click", handler);
        container.addEventListener("mouseover", handler);
        container.addEventListener("mouseout", handler);

        // Store listener reference in centralized state for cleanup
        this._state.eventListener = handler;
    }

    renderErrorCard(entityId, message) {
        return '<div class="room-timeline"><div class="room-header"><ha-icon icon="mdi:alert-circle"></ha-icon><span class="room-name" data-entity-id="' + entityId + '" style="color:var(--error-color);">' + entityId + '</span></div><div class="timeline-container" style="padding:16px;text-align:center;"><div style="color:var(--secondary-text-color);">' + message + "</div></div></div>";
    }

    renderTimeline(roomName, roomIcon, allLayers, unitOfMeasurement, entityId, entityState) {
        // Validate inputs first
        if (!this._validateTimelineInputs(roomName, allLayers, entityId)) {
            return this.renderErrorCard(entityId, "Invalid timeline data");
        }

        // Handle empty layers case
        if (!allLayers || allLayers.length === 0) {
            return this._renderEmptyTimeline(roomName, roomIcon, entityState, unitOfMeasurement, entityId);
        }

        // Prepare metadata once (reuse everywhere)
        const layersMetadata = this._prepareLayersMetadata(allLayers);
        const layersToDisplay = this._filterLayersForDisplay(allLayers, entityId, layersMetadata);

        // If nothing to display, show empty state
        if (layersToDisplay.length === 0) {
            return this._renderEmptyTimeline(roomName, roomIcon, entityState, unitOfMeasurement, entityId);
        }

        // Pre-calculate all dimensions
        const containerHeight = this._calculateContainerHeight(layersToDisplay.length);
        const {
            containerWidth
        } = this.getCachedDOMMetrics();

        // Render components
        const headerHtml = this.renderRoomHeader(roomName, roomIcon, entityState, unitOfMeasurement, entityId);
        const hourLabels = this._renderHourLabels();
        const {
            blockHtml,
            iconHtml
        } = this._renderAllBlocksAndIcons(
            layersToDisplay,
            allLayers,
            layersMetadata,
            containerWidth,
            unitOfMeasurement,
            entityId // Pass entityId for collapse state lookup
        );

        // Assembly - simple concatenation
        return `<div class="room-timeline"><div class="room-header">${headerHtml}</div><div class="timeline-wrapper"><div class="icon-column" style="height:${containerHeight}px;position:relative;">${iconHtml}</div><div class="timeline-container" style="height:${containerHeight}px;flex:1;"><div class="timeline-grid">${hourLabels}</div><div class="blocks-container" style="position:relative;height:${containerHeight}px;">${blockHtml}</div></div></div></div>`;
    }

    _validateTimelineInputs(roomName, allLayers, entityId) {
        if (!roomName || typeof roomName !== "string") return false;
        if (!Array.isArray(allLayers)) return false;
        if (!entityId || typeof entityId !== "string") return false;
        return true;
    }

    _renderEmptyTimeline(roomName, roomIcon, entityState, unitOfMeasurement, entityId) {
        const headerHtml = this.renderRoomHeader(roomName, roomIcon, entityState, unitOfMeasurement, entityId);
        return `<div class="room-timeline"><div class="room-header">${headerHtml}</div><div class="timeline-container"><div class="no-schedule">${this.t("no_schedule")}</div></div></div>`;
    }

    _prepareLayersMetadata(allLayers) {
        const metadata = new Map();

        allLayers.forEach((layer, idx) => {
            const isDefault = layer.is_default_layer === true;
            const isCombined = layer.is_combined_layer === true;
            const isActive = !isDefault && !isCombined ?
                this._evaluateConditionsForLayer(layer) :
                null;

            metadata.set(layer, {
                index: idx,
                isDefault,
                isCombined,
                isActive,
                conditionText: this._translateConditionText(layer.condition_text || "")
            });
        });

        return metadata;
    }

    _filterLayersForDisplay(allLayers, entityId, layersMetadata) {
        // Initialize visibility state with default collapsed state
        this._state.initializeLayerVisibility(entityId, false);
        const isExpanded = this._state.isLayerVisible(entityId);
        const result = [];

        // When COLLAPSED (false), show ONLY the combined layer (Σ)
        if (!isExpanded) {
            return allLayers.filter(l => l.is_combined_layer === true);
        }

        // When EXPANDED (true), display in CORRECT ORDER:

        // 1. Layer 0 (DEFAULT) - ALWAYS FIRST
        const defaultLayer = allLayers.find(l => l.is_default_layer);
        if (defaultLayer) {
            result.push(defaultLayer);
        }

        // 2. Conditional layers (Layer 1, 2, 3, etc.) - in order
        for (const layer of allLayers) {
            if (!layer.is_default_layer && !layer.is_combined_layer) {
                result.push(layer);
            }
        }

        // 3. Combined layer (Σ) - ALWAYS LAST
        const combinedLayer = allLayers.find(l => l.is_combined_layer);
        if (combinedLayer) {
            result.push(combinedLayer);
        }

        return result;
    }

    _renderHourLabels() {
        const use12HourFormat = this.use12HourFormat();
        const hours = Array.from({
            length: 24
        }, (_, i) => i);

        // In 12-hour format, show labels at different hours for better spacing
        const hoursToShow = use12HourFormat ? [6, 12, 18] // 6 AM, 12 PM, 6 PM
            :
            [6, 12, 18]; // Same spacing for 24h, but formatHour will render as "6h", "12h", "18h"

        return hours.map(h =>
            hoursToShow.includes(h) ?
            `<div class="timeline-hour">${escapeHtml(this.formatHour(h))}</div>` :
            '<div class="timeline-hour"></div>'
        ).join("");
    }

    _renderAllBlocksAndIcons(layersToDisplay, allLayers, layersMetadata, containerWidth, unitOfMeasurement, entityId) {
        const blockParts = [];
        const iconParts = [];
        const isSelectedDayToday = this.isToday();

        for (let layerIdx = 0; layerIdx < layersToDisplay.length; layerIdx++) {
            const currentLayer = layersToDisplay[layerIdx];
            const meta = layersMetadata.get(currentLayer);

            if (!meta || !currentLayer.blocks) continue;

            // Calculate vertical position
            const top = LAYOUT_CONSTANTS.TOP_MARGIN +
                layerIdx * (LAYOUT_CONSTANTS.BLOCK_HEIGHT + LAYOUT_CONSTANTS.VERTICAL_GAP);

            // Render icon for this layer
            const iconHtml = this._renderLayerIcon(
                currentLayer,
                meta,
                allLayers,
                layersToDisplay,
                top,
                isSelectedDayToday,
                entityId // Pass entityId to icon renderer
            );
            if (iconHtml) iconParts.push(iconHtml);

            // Render all blocks in this layer
            for (const block of currentLayer.blocks) {
                const blockHtml = this._renderBlock(
                    block,
                    currentLayer,
                    meta,
                    top,
                    containerWidth,
                    unitOfMeasurement,
                    isSelectedDayToday
                );
                if (blockHtml) blockParts.push(blockHtml);
            }
        }

        return {
            blockHtml: blockParts.join(""),
            iconHtml: iconParts.join("")
        };
    }

    _renderLayerIcon(currentLayer, meta, allLayers, layersToDisplay, top, isSelectedDayToday, entityId) {
        if (meta.isCombined) {
            return this._renderCombinedLayerIcon(currentLayer, meta, allLayers, layersToDisplay, top, isSelectedDayToday, entityId);
        } else {
            return this._renderConditionalLayerIcon(currentLayer, meta, allLayers, layersToDisplay, top, isSelectedDayToday);
        }
    }

    _renderCombinedLayerIcon(currentLayer, meta, allLayers, layersToDisplay, top, isSelectedDayToday, entityId) {
        const defaultLayer = allLayers.find(l => l.is_default_layer);
        const conditionalLayers = allLayers.filter(l => !l.is_default_layer && !l.is_combined_layer);
        const hasCollapsibleLayers = defaultLayer || conditionalLayers.length > 0;

        let toggleClass = "";
        let iconStyle = `background:${this._colors.combined_folded_layer};filter:brightness(1.1);`;

        // Adjust for non-today selected
        if (!isSelectedDayToday) {
            iconStyle = `background:${this._colors.combined_folded_layer};opacity:0.5;filter:brightness(0.8);`;
        }

        // If there are collapsible layers, add toggle class and check collapsed state
        if (hasCollapsibleLayers) {
            toggleClass = " combined-layer-toggle";

            // Check if layers are expanded using entityId
            const isExpanded = this._state.isLayerVisible(entityId);

            if (isExpanded) {
                // Layers are expanded = show unfolded color
                iconStyle = `background:${this._colors.combined_unfolded_layer};filter:brightness(1.3);`;
                if (!isSelectedDayToday) {
                    iconStyle = `background:${this._colors.combined_unfolded_layer};opacity:0.5;filter:brightness(0.8);`;
                }
            }
        }

        const iconTooltip = escapeHtml(this.t("cond_combined_schedule_toggle"));

        return `<div class="icon-row combined-icon-row" style="top:${top}px;" data-tooltip="${iconTooltip}"><span class="layer-number${toggleClass}" data-entity-id="${escapeHtml(entityId)}" style="${iconStyle}">Σ</span></div>`;
    }


    _renderConditionalLayerIcon(currentLayer, meta, allLayers, layersToDisplay, top, isSelectedDayToday) {
        const conditionalLayers = allLayers.filter(l => !l.is_default_layer && !l.is_combined_layer);

        let displayLayerIndex = "";
        let iconTooltipText = "";

        if (meta.isDefault) {
            displayLayerIndex = "0";
            iconTooltipText = this.t("layer_label") + " 0";

            if (meta.conditionText) {
                iconTooltipText += meta.isActive ? "\n✅ " : "\n❌ ";
                iconTooltipText += this.t("condition_label") + ": " + meta.conditionText;
            } else {
                iconTooltipText += "\n" + this.t("default_state_label");
            }
        } else {
            const condLayerIndex = conditionalLayers.findIndex(l => l === currentLayer);
            displayLayerIndex = String(condLayerIndex + 1);

            iconTooltipText = this.t("layer_label") + " " + displayLayerIndex;
            if (meta.conditionText) {
                iconTooltipText += meta.isActive ? "\n✅ " : "\n❌ ";
                iconTooltipText += this.t("condition_label") + ": " + meta.conditionText;
            } else {
                iconTooltipText += "\n" + this.t("no_specific_condition");
            }
        }

        const iconStyle = meta.isActive ?
            `background:${this._colors.active_layer};filter:brightness(1.3);` :
            `background:${this._colors.inactive_layer};opacity:0.5;`;

        const opacityAdjust = !isSelectedDayToday ? "opacity:0.5;" : "";
        const finalStyle = opacityAdjust ? `${iconStyle}${opacityAdjust}` : iconStyle;

        return `<div class="icon-row" style="top:${top}px;" data-tooltip="${escapeHtml(iconTooltipText)}"><span class="layer-number" style="${finalStyle}">${escapeHtml(displayLayerIndex)}</span></div>`;
    }

    _renderBlock(block, currentLayer, meta, top, containerWidth, unitOfMeasurement, isSelectedDayToday) {
        // PERFORMANCE OPTIMIZATION: Use cached block metrics
        // This eliminates redundant time parsing and calculations
        const metrics = this._getBlockMetrics(block);
        const {
            startMin,
            endMin,
            dimensions,
            borderRadius
        } = metrics;
        const {
            left,
            width
        } = dimensions;

        // Get state and color
        const rawState = block.state_value || "";
        const rawTemplate = block.raw_state_template || rawState;
        const isDynamic = this.isDynamicTemplate(rawTemplate);
        const resolvedState = this.resolveTemplate(rawState);
        const unit = block.unit || unitOfMeasurement || "";

        // Use escapeHtml for text content (preserves "/" for units like €/kWh)
        const escapedState = escapeHtml(resolvedState);
        const escapedUnit = escapeHtml(unit);
        const stateDisplay = escapedState?.trim() ?
            (escapedUnit ? escapedState + " " + escapedUnit : escapedState) :
            "";

        // Get colors
        const colorData = this.getColorForState(resolvedState || "default", unit || unitOfMeasurement);
        const color = block.color || colorData.color;
        const textColor = colorData.textColor;

        // Build CSS classes - PRESERVE HATCHING FOR DEFAULT BLOCKS IN COMBINED LAYER
        let blockClass = "schedule-block";

        // Add layer-specific styling
        if (meta.isCombined) {
            blockClass += " combined-layer-block sch-z-combined";

            // CRITICAL FIX: Preserve hatching pattern for default blocks in combined layer
            if (block.is_default_bg) {
                blockClass += " default-block";
            }
        } else if (block.is_default_bg) {
            // Default layer: add hatching
            blockClass += " default-block sch-z-default";
        } else {
            // Conditional layer: solid color
            blockClass += " sch-z-layer";
        }

        // Add dynamic indicator
        if (isDynamic) blockClass += " dynamic";

        // Build styles
        const style = `left:${left}%;width:${width}%;top:${top}px;border-radius:${borderRadius};color:${this.validateStyleValue(textColor)};background-color:${this.validateStyleValue(color)};`;

        // Truncate text to fit block width
        const blockWidthPx = (width / 100) * containerWidth;
        const displayText = this.truncateText(stateDisplay, blockWidthPx);

        // Build tooltip (with escapeHtmlAttribute for data attribute)
        const tooltip = this._buildBlockTooltip({
            block,
            isWrapped: block.wraps_start || block.wraps_end,
            isDynamic,
            isCombined: meta.isCombined,
            isDefault: block.is_default_bg,
            escapedState,
            escapedUnit
        });

        // Display only text on block (no icon)
        return `<div class="${blockClass}" style="${style}" data-tooltip="${escapeHtmlAttribute(tooltip)}"><span class="block-center">${escapeHtml(displayText)}</span></div>`;
    }

    updateContent() {
        if (!this._hass) return;

        const content = this.shadowRoot.querySelector("#content");
        if (!content) return;

        // CLEANUP: Remove old listeners before creating new content
        if (this._state.eventListener) {
            content.removeEventListener("click", this._state.eventListener);
            content.removeEventListener("mouseover", this._state.eventListener);
            content.removeEventListener("mouseout", this._state.eventListener);
            this._state.eventListener = null;
        }

        // Invalidate DOM cache for next render
        this._state.invalidateDOMCache();

        // PERFORMANCE FIX: Clear block metrics cache for fresh calculations on new render
        if (this._blockMetricsCache) {
            this._blockMetricsCache.clear();
        }

        let timelines = "";

        for (let i = 0; i < this._config.entities.length; i++) {
            const entityConfig = this._config.entities[i];
            const entityId = typeof entityConfig === "string" ? entityConfig : entityConfig.entity;

            if (!entityId) continue;

            // Initialize visibility in centralized state
            this._state.initializeLayerVisibility(entityId, false);

            const state = this._hass.states[entityId];

            if (!state) {
                timelines += this.renderErrorCard(entityId, this.t("entity_not_found"));
                continue;
            }

            const attrs = state.attributes || {};
            const layers = attrs.layers || {};

            const customName = typeof entityConfig === "object" ? entityConfig.name : null;
            const customIcon = typeof entityConfig === "object" ? entityConfig.icon : null;
            const roomName = customName || attrs.room || attrs.friendly_name || entityId;
            const roomIcon = customIcon || attrs.icon || "mdi:thermometer";
            const unitOfMeasurement = attrs.unit_of_measurement || "";

            let dayLayers = layers[this.selectedDay] || [];

            const defaultLayer = dayLayers.find(l => l.is_default_layer);
            const allConditionalLayers = dayLayers.filter(layer =>
                !layer.is_default_layer && !layer.is_combined_layer
            );

            const activeConditionalLayers = allConditionalLayers.filter(layer =>
                this._evaluateConditionsForLayer(layer)
            );

            const combinedLayer = this.createCombinedLayer(defaultLayer, activeConditionalLayers);

            let allLayers = dayLayers.filter(l => !l.is_combined_layer);

            if (combinedLayer) {
                allLayers = [...allLayers, combinedLayer];
            }

            timelines += this.renderTimeline(roomName, roomIcon, allLayers, unitOfMeasurement, entityId, state);
        }

        const newHTML = `<div class="schedules-container">${timelines}</div>`;

        if (content.innerHTML !== newHTML) {
            content.innerHTML = newHTML;
            // Attach listeners AFTER DOM is updated (prevents listener duplication)
            this.attachAllListeners();
        }

        this.updateTimeline();
    }

    renderRoomHeader(roomName, roomIcon, entityState, unitOfMeasurement, entityId) {
        const showStateInTitle = this._config.show_state_in_title !== false;
        let stateValue = "";

        if (showStateInTitle && entityState) {
            const attrs = entityState.attributes || {};
            const state = entityState.state || "";
            const unit = unitOfMeasurement || attrs.unit_of_measurement || "";

            // Use escapeHtml (not escapeHtmlAttribute) for text content
            const escapedState = escapeHtml(state);
            const escapedUnit = escapeHtml(unit);

            stateValue = escapedState ?
                (escapedUnit ? escapedState + " " + escapedUnit : escapedState) : "";
        }

        // Use escapeHtmlAttribute for attribute values
        const escapedRoomName = escapeHtml(roomName);
        const escapedRoomIcon = escapeHtmlAttribute(roomIcon || "");
        const escapedEntityId = escapeHtmlAttribute(entityId);

        // Build header HTML with proper escaping
        let headerHtml = "";

        if (escapedRoomIcon) {
            headerHtml += '<ha-icon icon="' + escapedRoomIcon + '"></ha-icon>';
        }

        headerHtml += '<span class="room-name" data-entity-id="' + escapedEntityId + '">' + escapedRoomName + '</span>';

        if (stateValue) {
            headerHtml += '<span class="room-state">' + stateValue + '</span>';
        }

        return headerHtml;
    }

    render() {
        const days = this.getDays();
        const showTitle = this._config.title?.trim().length > 0;

        const blockHeight = ScheduleStateCard.BLOCK_HEIGHT;
        const iconColumnWidth = ScheduleStateCard.ICON_COLUMN_WIDTH;

        const additionalStyle = `
            .schedule-block.combined-layer-block{opacity:1;border:1px dashed var(--primary-text-color);box-shadow:0 0 10px var(--info-color);z-index:1!important}
            .icon-row.combined-icon-row .layer-number{cursor:pointer;position:relative;font-size:16px!important;line-height:24px;overflow:hidden}
            .icon-row.combined-icon-row .layer-number:hover{filter:brightness(1.3)}
            .combined-layer-toggle{padding-left:0;padding-right:0}
            .sch-z-default{z-index:1}
            .sch-z-layer{z-index:1}
            .sch-z-combined{z-index:1}
            .layer-number{width:24px;height:24px;color:white;border-radius:50%;font-size:11px;font-weight:bold;display:flex;align-items:center;justify-content:center;transition:all .2s}
        `;

        const styleContent = `
            :host {
                display: block;
                --sch-block-height: ${blockHeight}px;
                --sch-icon-col-width: ${iconColumnWidth}px;
            }
            ha-card{padding:16px}
            .card-header{display:flex;align-items:center;gap:12px;margin-bottom:16px}
            .card-header.hidden{display:none}
            .card-title{font-size:24px;font-weight:bold;margin:0}
            .day-selector{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:16px;justify-content: center}
            .day-button{padding:8px 6px;border:none;border-radius:8px;background:var(--primary-background-color);color:var(--primary-text-color);cursor:pointer;font-weight:500;transition:all .2s;border:1px solid var(--divider-color)}
            .day-button:hover{background:var(--secondary-background-color);border-color:var(--primary-color)}
            .day-button.active{background:var(--primary-color);color:var(--text-primary-color,white);border-color:var(--primary-color)}
            .schedules-container{display:flex;flex-direction:column;gap:24px}
            .room-timeline{margin-bottom:12px}
            .room-header{display:flex;align-items:center;gap:8px;padding:0 8px;justify-content:space-between}
            .room-name{font-weight:600;font-size:14px;color:var(--primary-text-color);flex-grow:1;cursor:pointer;transition:color 0.2s}
            .room-name:hover{color:var(--primary-color);text-decoration:underline}
            .room-state{font-weight:600;font-size:14px;color:var(--primary-color);margin-left:auto}
            .timeline-wrapper{display:flex;gap:0;align-items:stretch}
            
            .icon-column{position:relative;width:var(--sch-icon-col-width);flex-shrink:0;display:flex;flex-direction:column;z-index:1}
            .icon-row{position:absolute;display:flex;align-items:center;justify-content:center;cursor:help;width:100%;height:var(--sch-block-height);transition:all .2s;top:0;margin-top:6px;z-index:1}
            .icon-row:hover .layer-number{filter:brightness(1.3)!important}
            
            .timeline-container{position:relative;background:var(--secondary-background-color);border-radius:8px;border:1px solid var(--divider-color);overflow:visible;padding:4px;flex:1}
            .timeline-grid{position:absolute;inset:0;display:flex;pointer-events:none;z-index:0}
            .blocks-container{position:absolute;inset:0;overflow:visible}
            .timeline-hour{position:relative;flex:1;border-right:1px solid var(--secondary-text-color);opacity:.4;font-size:11px;color:var(--secondary-text-color);display:flex;align-items:flex-end;justify-content:center;font-weight:600;padding-bottom:4px}
            .timeline-hour:empty{font-size:0}
            .timeline-hour:last-child{border-right:none}
            
            .schedule-block{
                position:absolute;
                display:flex;
                align-items:center;
                justify-content:center;
                font-weight:500;
                box-shadow:0 1px 3px rgba(0,0,0,.3);
                cursor:help;
                text-align:center;
                font-size:12px;
                overflow:hidden;
                height: var(--sch-block-height);
            }
            .schedule-block.default-block{
                background-image:repeating-linear-gradient(45deg,transparent,transparent 6px,rgba(0,0,0,0.15) 6px,rgba(0,0,0,0.15) 12px)!important;
                color:white;
                font-weight:500;
            }
            .block-center{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);max-width:95%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}
            .no-schedule{font-size:14px;color:var(--secondary-text-color);text-align:center;padding:12px 0}
            .time-cursor{position:absolute;top:0;bottom:0;width:2px;background-color:var(--label-badge-yellow);z-index:2}
        ` + additionalStyle;

        const htmlContent = '<ha-card><div class="card-header' + (showTitle ? "" : " hidden") + '"><div class="card-title">' + (this._config.title || "") + '</div></div><div class="day-selector">' + days.map(day => '<button class="day-button' + (day.id === this.selectedDay ? " active" : "") + '" data-day="' + day.id + '">' + day.label + "</button>").join("") + '</div><div id="content"></div></ha-card>';
        this.shadowRoot.innerHTML = '<style>' + styleContent + "</style>" + htmlContent;
        this.updateContent();
        this.startTimelineUpdate();

        requestAnimationFrame(() => {
            const dayButtons = this.shadowRoot.querySelectorAll(".day-button");
            dayButtons.forEach(button => {
                button.addEventListener("click", e => {
                    const newDay = e.target.dataset.day;
                    if (newDay !== this.selectedDay) {
                        dayButtons.forEach(btn => btn.classList.remove("active"));
                        e.target.classList.add("active");

                        this.selectedDay = newDay;
                        this.updateContent();
                    }
                });
            });
        });
    }

    connectedCallback() {
        this.startTimelineUpdate();
    }

    disconnectedCallback() {
        /**
         * Complete cleanup when component is removed from DOM
         * Ensures no memory leaks or lingering resources
         */

        // Stop timeline updates
        this.stopTimelineUpdate();

        // âœ… COMPLETE CLEANUP VIA CENTRALIZED STATE
        this._state.resetOnDisconnect();

        // Clean up UI elements
        if (this.tooltipElement) {
            this.tooltipElement.remove();
            this.tooltipElement = null;
        }

        // PERFORMANCE FIX: Clear metrics cache to free memory
        if (this._blockMetricsCache) {
            this._blockMetricsCache.clear();
            this._blockMetricsCache = null;
        }

        // Detach remaining listeners
        const container = this.shadowRoot?.querySelector("#content");
        if (container && this._state.eventListener) {
            container.removeEventListener("click", this._state.eventListener);
            container.removeEventListener("mouseover", this._state.eventListener);
            container.removeEventListener("mouseout", this._state.eventListener);
        }
    }
}

class ScheduleStateCardEditor extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({
            mode: "open"
        });
        this._config = {};
        this._hass = null;
        this._entities = [];
        this._editingIndex = null;
        this._colorPickerOpen = null;
        this._iconsCache = null;
        this._lastUpdateTime = 0;
        this._updateDebounceTimer = null;
    }

    getDays() {
        const dayTranslations = TRANSLATIONS[this.getLanguage()]?.days || TRANSLATIONS.en.days;
        return ["mon", "tue", "wed", "thu", "fri", "sat", "sun"].map(id => ({
            id,
            label: dayTranslations[id]
        }));
    }

    getLanguage() {
        if (this._hass?.locale?.language) {
            return TRANSLATIONS[this._hass.locale.language] ? this._hass.locale.language : "en";
        }
        return "en";
    }

    t(key) {
        const lang = this.getLanguage();
        return TRANSLATIONS[lang] && TRANSLATIONS[lang][key] ? TRANSLATIONS[lang][key] : TRANSLATIONS.en[key] || key;
    }

    setConfig(config) {
        if (!config) throw new Error("Invalid configuration");
        let entities = config.entities || [];
        this._config = {
            ...config,
            entities: Array.isArray(entities) ? entities.map(e => typeof e === "string" ? {
                entity: e
            } : e) : [],
            show_state_in_title: config.show_state_in_title !== false
        };
        if (config.colors) {
            this._colors = {
                ...DEFAULT_COLORS,
                ...config.colors
            };
        } else {
            this._colors = {
                ...DEFAULT_COLORS
            };
        }
        this._clearCaches();
        if (this._hass) this.render();
    }

    set hass(hass) {
        this._hass = hass;
        if (this._config?.entities && !this.shadowRoot.querySelector("ha-card")) {
            this.render();
        }
    }

    getFilteredEntities(filterText) {
        const allEntities = Object.keys(this._hass?.states || {}).sort();
        if (!filterText) return allEntities.slice(0, 10);
        return allEntities.filter(e => e.toLowerCase().includes(filterText.toLowerCase()));
    }

    getFilteredIcons(filterText) {
        const allIcons = this.getAllMDIIcons();
        if (!filterText) return allIcons.slice(0, 20);
        return allIcons.filter(i => i.toLowerCase().includes(filterText.toLowerCase())).slice(0, 50);
    }

    getAllMDIIcons() {
        if (this._iconsCache) return this._iconsCache;
        let iconList = [];
        try {
            const resources = this._hass?.resources;
            if (resources) {
                for (const [key, value] of Object.entries(resources)) {
                    if (typeof value === 'object' && value !== null) {
                        const icons = Object.keys(value).filter(icon => icon.startsWith('mdi:'));
                        iconList.push(...icons);
                    }
                }
            }
        } catch (e) {
            console.log("Error retrieving icons:", e);
        }
        if (iconList.length === 0) {
            iconList = ["mdi:calendar-clock", "mdi:thermometer", "mdi:lightbulb", "mdi:power", "mdi:weather-sunny", "mdi:water", "mdi:motion-sensor", "mdi:door", "mdi:window-closed", "mdi:fan", "mdi:air-conditioner", "mdi:television", "mdi:music", "mdi:lock", "mdi:shield", "mdi:alarm", "mdi:clock", "mdi:timer", "mdi:play", "mdi:stop", "mdi:pause", "mdi:volume-high", "mdi:brightness-7", "mdi:home", "mdi:sofa", "mdi:bed", "mdi:check", "mdi:close"];
        }
        const uniqueIcons = [...new Set(iconList)].sort();
        this._iconsCache = uniqueIcons;
        return uniqueIcons;
    }

    fireConfigChanged() {
        this._config.entities = this._entities;
        this.dispatchEvent(new CustomEvent("config-changed", {
            detail: {
                config: this._config
            }
        }));
    }

    addEntity() {
        this._entities.push({
            entity: "",
            name: "",
            icon: ""
        });
        this.fireConfigChanged();
        this.render();
    }

    removeEntity(index) {
        this._entities.splice(index, 1);
        this.fireConfigChanged();
        this.render();
    }

    updateEntity(index, field, value) {
        if (this._entities[index]) {
            this._entities[index][field] = value;
            this.fireConfigChanged();
        }
    }

    updateColor(colorKey, value) {
        if (!this._config.colors) {
            this._config.colors = {
                ...DEFAULT_COLORS
            };
        }
        this._config.colors[colorKey] = value;
        this.fireConfigChanged();
        this.render();
    }

    toggleEditForm(index) {
        this._editingIndex = this._editingIndex === index ? null : index;
        this.render();
    }

    toggleColorPicker(colorKey) {
        this._colorPickerOpen = this._colorPickerOpen === colorKey ? null : colorKey;
        this.render();
    }

    isValidHex(hex) {
        if (!hex || typeof hex !== 'string') return false;
        
        // Accept CSS variables with fallback colors
        if (hex.includes('var(')) {
            return true; // CSS variables are valid
        }
        
        // Accept hex color format (#RRGGBB)
        return /^#[0-9A-F]{6}$/i.test(hex);
    }

    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }

    rgbToHex(r, g, b) {
        return "#" + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? "0" + hex : hex;
        }).join("").toUpperCase();
    }

    rgbToHsv(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h = 0,
            s = 0;
        const v = max;
        const d = max - min;
        s = max === 0 ? 0 : d / max;
        if (max === min) {
            h = 0;
        } else {
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return {
            h: h * 360,
            s: s * 100,
            v: v * 100
        };
    }

    hsvToRgb(h, s, v) {
        h = h / 360;
        s = s / 100;
        v = v / 100;
        const c = v * s;
        const x = c * (1 - Math.abs((h * 6) % 2 - 1));
        const m = v - c;
        let r = 0,
            g = 0,
            b = 0;
        if (h < 1 / 6) {
            r = c;
            g = x;
            b = 0;
        } else if (h < 2 / 6) {
            r = x;
            g = c;
            b = 0;
        } else if (h < 3 / 6) {
            r = 0;
            g = c;
            b = x;
        } else if (h < 4 / 6) {
            r = 0;
            g = x;
            b = c;
        } else if (h < 5 / 6) {
            r = x;
            g = 0;
            b = c;
        } else {
            r = c;
            g = 0;
            b = x;
        }
        r = Math.round((r + m) * 255);
        g = Math.round((g + m) * 255);
        b = Math.round((b + m) * 255);
        return {
            r,
            g,
            b
        };
    }

    renderEditForm(entityConfig, index) {
        const t = this.t.bind(this);
        const entityId = entityConfig.entity || "";
        return `<div class="entity-edit-form"><div class="input-group"><label>${t('editor_entity_id_label')}:</label><div class="input-with-suggestions"><input type="text" class="entity-input entity-search" data-index="${index}" data-field="entity" value="${escapeHtml(entityId)}" placeholder="light.my_light" autocomplete="off"></div></div><div class="input-group"><label>${t('editor_name_label')}:</label><input type="text" class="entity-input" data-index="${index}" data-field="name" value="${escapeHtml(entityConfig.name || '')}" placeholder="${t('editor_placeholder_name')}" autocomplete="off"></div><div class="input-group"><label>${t('editor_icon_label')}:</label><div class="input-with-suggestions"><input type="text" class="entity-input icon-search" data-index="${index}" data-field="icon" value="${escapeHtml(entityConfig.icon || '')}" placeholder="mdi:calendar-clock" autocomplete="off"></div></div></div>`;
    }

    renderEntityRow(entityConfig, index) {
        const t = this.t.bind(this);
        const entityId = entityConfig.entity || "";
        const entityState = this._hass?.states[entityId];
        const name = entityConfig.name || entityState?.attributes?.friendly_name || entityId || t('editor_default_entity_name');
        const icon = entityConfig.icon || entityState?.attributes?.icon || "mdi:calendar-clock";
        const isEditing = this._editingIndex === index;
        return `<div class="entity-row"><div class="handle">≡</div><div class="icon-name"><ha-icon icon="${escapeHtml(icon)}"></ha-icon><span>${escapeHtml(name)}</span></div><div class="entity-id">${escapeHtml(entityId)}</div><div class="actions"><button class="action-button edit-btn" data-index="${index}" title="${t('common.edit') || 'Edit'}"><ha-icon icon="mdi:pencil"></ha-icon></button><button class="action-button remove-btn" data-index="${index}" title="${t('common.delete') || 'Delete'}"><ha-icon icon="mdi:close"></ha-icon></button></div></div>${isEditing ? this.renderEditForm(entityConfig, index) : ''}`;
    }

    renderColorPicker(colorKey, colorLabel) {
        const currentColor = this._config.colors?.[colorKey] || DEFAULT_COLORS[colorKey];
        const isOpen = this._colorPickerOpen === colorKey;
        const rgb = this.hexToRgb(currentColor);
        const hsv = rgb ? this.rgbToHsv(rgb.r, rgb.g, rgb.b) : {
            h: 0,
            s: 100,
            v: 100
        };
        const pickerHtml = isOpen ? `<div class="color-picker-overlay" data-colorkey="${colorKey}"></div><div class="color-picker-popup"><div class="color-wheel-container"><canvas id="color-wheel-${colorKey}" class="color-wheel" width="280" height="280" data-colorkey="${colorKey}"></canvas><div class="color-marker" id="marker-${colorKey}" style="position: absolute; width: 12px; height: 12px; border: 2px solid white; border-radius: 50%; box-shadow: 0 0 4px rgba(0,0,0,0.5); pointer-events: none;"></div></div><div class="brightness-control"><label>Brightness: <span id="brightness-value-${colorKey}">100</span>%</label><input type="range" class="brightness-slider" id="brightness-${colorKey}" min="0" max="100" value="${hsv.v}" data-colorkey="${colorKey}" /></div></div>` : '';
        return `<div class="color-config-row"><label>${colorLabel}</label><div class="color-input-group"><div class="color-preview" style="background-color: ${currentColor};" data-colorkey="${colorKey}"></div><input type="text" class="color-hex-input" value="${currentColor}" data-colorkey="${colorKey}" maxlength="7" placeholder="#000000" /><button class="color-picker-btn" data-colorkey="${colorKey}" title="${this.t('editor_color_picker_label')}">🎨</button></div>${pickerHtml}</div>`;
    }

    render() {
        const t = this.t.bind(this);
        if (this._config?.entities) this._entities = this._config.entities;
        const entityRows = this._entities.map((entity, index) => this.renderEntityRow(entity, index)).join('');
        const colorConfigsHtml = [
            this.renderColorPicker('active_layer', t('editor_active_layer_label')),
            this.renderColorPicker('inactive_layer', t('editor_inactive_layer_label')),
            this.renderColorPicker('combined_folded_layer', t('editor_combined_folded_label')),
            this.renderColorPicker('combined_unfolded_layer', t('editor_combined_unfolded_label')),
            this.renderColorPicker('cursor', t('editor_cursor_label'))
        ].join('');

        const styleContent = `:host { display: block; } ha-card { padding: 16px; } .editor-header { font-size: 20px; font-weight: bold; margin-bottom: 16px; } .form-section { margin-bottom: 24px; } .section-title { font-size: 16px; font-weight: 600; margin-bottom: 12px; color: var(--primary-text-color); } .input-group { display: flex; flex-direction: column; gap: 6px; margin-bottom: 12px; } .input-group label { font-weight: 500; font-size: 14px; color: var(--primary-text-color); } .input-group input[type="text"], .input-group input[type="checkbox"] { padding: 8px; border: 1px solid var(--divider-color); border-radius: 4px; background: var(--primary-background-color); color: var(--primary-text-color); font-size: 14px; } .input-group input[type="checkbox"] { width: auto; margin-top: 4px; } .input-group input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 2px var(--primary-color)33; } .input-with-suggestions { position: relative; width: 100%; } .suggestions-dropdown { position: absolute; top: 100%; left: 0; right: 0; background: var(--primary-background-color); border: 1px solid var(--divider-color); border-top: none; border-radius: 0 0 4px 4px; max-height: 250px; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); } .suggestion-item { padding: 8px 12px; cursor: pointer; color: var(--primary-text-color); display: flex; align-items: center; gap: 8px; transition: background 0.2s; } .suggestion-item:hover:not(.disabled) { background: var(--primary-color); color: white; } .suggestion-item.disabled { opacity: 0.5; cursor: default; } .entity-row { display: flex; gap: 12px; align-items: center; padding: 12px; background: var(--secondary-background-color); border: 1px solid var(--divider-color); border-radius: 6px; margin-bottom: 8px; } .handle { cursor: grab; color: var(--secondary-text-color); font-weight: bold; user-select: none; } .icon-name { display: flex; align-items: center; gap: 8px; flex: 0 0 auto; } .entity-id { flex: 1; font-size: 12px; color: var(--secondary-text-color); font-family: monospace; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .actions { display: flex; gap: 4px; } .action-button { background: transparent; border: 1px solid var(--divider-color); border-radius: 4px; padding: 4px 8px; cursor: pointer; display: flex; align-items: center; color: var(--primary-text-color); transition: all 0.2s; } .action-button:hover { background: var(--primary-color); border-color: var(--primary-color); color: white; } .entity-edit-form { background: var(--primary-background-color); padding: 12px; border-radius: 4px; margin-top: 8px; border: 1px solid var(--primary-color); } .entity-input { width: 100%; padding: 8px; border: 1px solid var(--divider-color); border-radius: 4px; background: var(--primary-background-color); color: var(--primary-text-color); font-size: 14px; box-sizing: border-box; } .entity-input:focus { outline: none; border-color: var(--primary-color); } .add-button { background: var(--primary-color); color: white; border: none; padding: 10px 16px; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 14px; transition: all 0.2s; width: 100%; } .add-button:hover { opacity: 0.9; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); } .color-config-row { display: flex; flex-direction: column; gap: 8px; padding: 12px; background: var(--secondary-background-color); border: 1px solid var(--divider-color); border-radius: 6px; margin-bottom: 8px; } .color-config-row label { font-weight: 500; font-size: 13px; } .color-input-group { display: flex; gap: 8px; align-items: center; } .color-preview { width: 40px; height: 40px; border: 1px solid var(--divider-color); border-radius: 4px; cursor: pointer; transition: all 0.2s; } .color-preview:hover { box-shadow: 0 0 8px rgba(0, 0, 0, 0.3); } .color-hex-input { flex: 1; padding: 8px; border: 1px solid var(--divider-color); border-radius: 4px; background: var(--primary-background-color); color: var(--primary-text-color); font-size: 14px; font-family: monospace; } .color-hex-input:focus { outline: none; border-color: var(--primary-color); } .color-picker-btn { background: transparent; border: 1px solid var(--divider-color); padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 18px; transition: all 0.2s; } .color-picker-btn:hover { background: var(--primary-color); border-color: var(--primary-color); } .color-picker-popup { position: absolute; top: 100%; left: 0; background: var(--primary-background-color); border: 1px solid var(--divider-color); border-radius: 6px; padding: 12px; z-index: 1001; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); margin-top: 4px; } .color-picker-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 999; } .color-wheel-container { position: relative; width: 280px; height: 280px; margin-bottom: 12px; } .color-wheel { cursor: crosshair; border-radius: 50%; } .brightness-control { display: flex; flex-direction: column; gap: 6px; } .brightness-control label { font-size: 13px; } .brightness-slider { width: 100%; height: 6px; border-radius: 3px; outline: none; -webkit-appearance: none; appearance: none; } .brightness-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--primary-color); cursor: pointer; } .brightness-slider::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: var(--primary-color); cursor: pointer; border: none; } .divider { height: 1px; background: var(--divider-color); margin: 16px 0; }`;

        const htmlContent = `<div class="editor-header">${t('editor_title')}</div><div class="form-section"><div class="section-title">${t('editor_card_title')}</div><div class="input-group"><input type="text" id="title-input" value="${escapeHtml(this._config.title || '')}" placeholder="${t('editor_title_placeholder')}"></div></div><div class="form-section"><div class="input-group"><label><input type="checkbox" id="show-state-input" ${this._config.show_state_in_title ? 'checked' : ''}>${t('editor_show_state_in_title')}</label></div></div><div class="divider"></div><div class="form-section"><div class="section-title">${t('editor_entities_label')}</div><div id="entities-list">${entityRows || '<div style="color: var(--secondary-text-color); text-align: center; padding: 20px;">' + t('editor_no_entities') + '</div>'}</div><button class="add-button" id="add-btn">+ ${t('editor_add_entity')}</button></div><div class="divider"></div><div class="form-section"><div class="section-title">${t('editor_colors_label')}</div>${colorConfigsHtml}</div>`;

        this.shadowRoot.innerHTML = `<style>${styleContent}</style><ha-card>${htmlContent}</ha-card>`;

        requestAnimationFrame(() => {
            this.attachListeners();
        });
    }

    // Draw color wheel canvas with HSV color space
    drawColorWheel(canvas, colorKey) {
        if (!canvas || !colorKey) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        const radius = 130;
        const centerX = 140;
        const centerY = 140;
        const currentColor = this._config.colors?.[colorKey] || DEFAULT_COLORS[colorKey];
        const rgb = this.hexToRgb(currentColor);
        const hsv = rgb ? this.rgbToHsv(rgb.r, rgb.g, rgb.b) : {
            h: 0,
            s: 100,
            v: 100
        };
        for (let angle = 0; angle < 360; angle += 1) {
            const startAngle = (angle - 90) * Math.PI / 180;
            const endAngle = (angle + 1 - 90) * Math.PI / 180;
            for (let r = 0; r < radius; r += 2) {
                const saturation = (r / radius) * 100;
                const rgb1 = this.hsvToRgb(angle, saturation, hsv.v);
                const rgbColor = `rgb(${rgb1.r},${rgb1.g},${rgb1.b})`;
                ctx.fillStyle = rgbColor;
                ctx.beginPath();
                ctx.arc(centerX, centerY, r, startAngle, endAngle);
                ctx.lineTo(centerX, centerY);
                ctx.fill();
            }
        }
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(centerX, centerY, 8, 0, 2 * Math.PI);
        ctx.fill();
        const angle = (hsv.h - 90) * Math.PI / 180;
        const distance = (hsv.s / 100) * radius;
        const markerX = centerX + distance * Math.cos(angle);
        const markerY = centerY + distance * Math.sin(angle);
        const marker = this.shadowRoot.querySelector(`#marker-${colorKey}`);
        if (marker) {
            marker.style.left = (markerX - 6) + 'px';
            marker.style.top = (markerY - 6) + 'px';
        }
    }

    // Handle color wheel click/drag to select color
    handleWheelClick(e, colorKey) {
        const canvas = e.target;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left - 140;
        const y = e.clientY - rect.top - 140;
        const distance = Math.sqrt(x * x + y * y);
        if (distance > 130) return;
        const angle = Math.atan2(y, x) * 180 / Math.PI + 90;
        const h = angle < 0 ? angle + 360 : angle;
        const s = (distance / 130) * 100;
        const brightnessSlider = this.shadowRoot.querySelector(`.brightness-slider[data-colorkey="${colorKey}"]`);
        const v = brightnessSlider ? parseInt(brightnessSlider.value) : 100;
        const rgb = this.hsvToRgb(h, s, v);
        const hex = this.rgbToHex(rgb.r, rgb.g, rgb.b);
        this.updateColor(colorKey, hex);
        this.drawColorWheel(canvas, colorKey);
    }

    // Update dropdown suggestions for entity/icon search
    updateDropdown(inputElement, type) {
        const index = parseInt(inputElement.dataset.index);
        const container = inputElement.closest('.input-with-suggestions');
        if (!container) return;
        const filterText = inputElement.value || "";
        let items = "";
        if (type === "entity") {
            const filtered = this.getFilteredEntities(filterText);
            if (filtered.length > 0) {
                items = filtered.map(e => `<div class="suggestion-item entity-suggestion" data-index="${index}" data-value="${escapeHtml(e)}">${escapeHtml(e)}</div>`).join('');
            } else if (filterText.length > 0) {
                items = `<div class="suggestion-item disabled">${this.t('editor_no_entities_found')}</div>`;
            }
        } else if (type === "icon") {
            const filtered = this.getFilteredIcons(filterText);
            if (filtered.length > 0) {
                items = filtered.map(icon => `<div class="suggestion-item icon-suggestion" data-index="${index}" data-value="${escapeHtml(icon)}"><ha-icon icon="${escapeHtml(icon)}"></ha-icon> ${escapeHtml(icon)}</div>`).join('');
            }
        }
        let existingDropdown = container.querySelector('.suggestions-dropdown');
        if (existingDropdown) existingDropdown.remove();
        if (items) {
            const dropdown = document.createElement('div');
            dropdown.className = 'suggestions-dropdown';
            dropdown.innerHTML = items;
            container.appendChild(dropdown);
            dropdown.querySelectorAll('.suggestion-item:not(.disabled)').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const idx = parseInt(item.dataset.index);
                    const value = item.dataset.value;
                    const field = type === "entity" ? "entity" : "icon";
                    this.updateEntity(idx, field, value);
                    inputElement.value = value;
                    const dd = container.querySelector('.suggestions-dropdown');
                    if (dd) dd.remove();
                });
                item.addEventListener('mouseenter', () => {
                    dropdown.querySelectorAll('.suggestion-item').forEach(i => i.style.background = '');
                    item.style.background = 'var(--primary-color)';
                    item.style.color = 'white';
                });
                item.addEventListener('mouseleave', () => {
                    item.style.background = '';
                    item.style.color = 'var(--primary-text-color)';
                });
            });
        }
    }

    // Attach all event listeners to form controls and color picker
    attachListeners() {
        if (!this.shadowRoot) return;
        const titleInput = this.shadowRoot.querySelector("#title-input");
        const showStateInput = this.shadowRoot.querySelector("#show-state-input");
        const addBtn = this.shadowRoot.querySelector("#add-btn");
        if (!titleInput || !showStateInput || !addBtn) {
            setTimeout(() => this.attachListeners(), 50);
            return;
        }
        titleInput.addEventListener("change", (e) => {
            this._config.title = e.target.value;
            this.fireConfigChanged();
        });
        showStateInput.addEventListener("change", (e) => {
            this._config.show_state_in_title = e.target.checked;
            this.fireConfigChanged();
        });
        addBtn.addEventListener("click", () => this.addEntity());
        this.shadowRoot.querySelectorAll(".edit-btn").forEach(btn => {
            btn.addEventListener("click", (e) => {
                const index = parseInt(e.currentTarget.dataset.index);
                this.toggleEditForm(index);
            });
        });
        this.shadowRoot.querySelectorAll(".remove-btn").forEach(btn => {
            btn.addEventListener("click", (e) => {
                const index = parseInt(e.currentTarget.dataset.index);
                this.removeEntity(index);
            });
        });
        this.shadowRoot.querySelectorAll(".entity-input:not(.entity-search):not(.icon-search)").forEach(input => {
            input.addEventListener("change", (e) => {
                const index = parseInt(e.target.dataset.index);
                const field = e.target.dataset.field;
                this.updateEntity(index, field, e.target.value);
            });
        });
        // Entity search listeners - with real-time dropdown updates
        this.shadowRoot.querySelectorAll(".entity-search").forEach(input => {
            input.addEventListener("focus", (e) => {
                this.updateDropdown(e.target, "entity");
            });
            input.addEventListener("input", (e) => {
                this.updateDropdown(e.target, "entity");
            });
            input.addEventListener("blur", (e) => {
                setTimeout(() => {
                    const container = e.target.closest('.input-with-suggestions');
                    if (container) {
                        const dropdown = container.querySelector('.suggestions-dropdown');
                        if (dropdown) dropdown.remove();
                    }
                }, 150);
            });
            input.addEventListener("keydown", (e) => {
                if (e.key === "Escape") {
                    const container = e.target.closest('.input-with-suggestions');
                    if (container) {
                        const dropdown = container.querySelector('.suggestions-dropdown');
                        if (dropdown) dropdown.remove();
                    }
                }
            });
        });
        // Icon search listeners - with real-time dropdown updates
        this.shadowRoot.querySelectorAll(".icon-search").forEach(input => {
            input.addEventListener("focus", (e) => {
                this.updateDropdown(e.target, "icon");
            });
            input.addEventListener("input", (e) => {
                this.updateDropdown(e.target, "icon");
            });
            input.addEventListener("blur", (e) => {
                setTimeout(() => {
                    const container = e.target.closest('.input-with-suggestions');
                    if (container) {
                        const dropdown = container.querySelector('.suggestions-dropdown');
                        if (dropdown) dropdown.remove();
                    }
                }, 150);
            });
            input.addEventListener("keydown", (e) => {
                if (e.key === "Escape") {
                    const container = e.target.closest('.input-with-suggestions');
                    if (container) {
                        const dropdown = container.querySelector('.suggestions-dropdown');
                        if (dropdown) dropdown.remove();
                    }
                }
            });
        });
        // Color picker button listeners
        this.shadowRoot.querySelectorAll(".color-picker-btn").forEach(btn => {
            btn.addEventListener("click", (e) => {
                const colorKey = e.currentTarget.dataset.colorkey;
                this.toggleColorPicker(colorKey);
            });
        });
        // Color hex input listeners
        this.shadowRoot.querySelectorAll(".color-hex-input").forEach(input => {
            input.addEventListener("change", (e) => {
                const colorKey = e.target.dataset.colorkey;
                let value = e.target.value.toUpperCase();
                if (!this.isValidHex(value)) {
                    value = DEFAULT_COLORS[colorKey];
                }
                e.target.value = value;
                this.updateColor(colorKey, value);
            });
            input.addEventListener("input", (e) => {
                const colorKey = e.target.dataset.colorkey;
                const preview = this.shadowRoot.querySelector(`.color-preview[data-colorkey="${colorKey}"]`);
                let value = e.target.value.toUpperCase();
                if (this.isValidHex(value)) {
                    preview.style.backgroundColor = value;
                }
            });
        });
        // Color preview listeners
        this.shadowRoot.querySelectorAll(".color-preview").forEach(preview => {
            preview.addEventListener("click", (e) => {
                const colorKey = e.currentTarget.dataset.colorkey;
                this.toggleColorPicker(colorKey);
            });
        });
        // Color picker overlay close listener
        this.shadowRoot.querySelectorAll(".color-picker-overlay").forEach(overlay => {
            overlay.addEventListener("click", () => {
                this._colorPickerOpen = null;
                this.render();
            });
        });
        // Color wheel canvas rendering and interaction
        this.shadowRoot.querySelectorAll(".color-wheel").forEach(canvas => {
            const colorKey = canvas.dataset.colorkey;
            // Draw the color wheel
            this.drawColorWheel(canvas, colorKey);
            // Click to select color
            canvas.addEventListener("click", (e) => this.handleWheelClick(e, colorKey));
            // Drag to select color
            canvas.addEventListener("mousemove", (e) => {
                if (e.buttons === 1) this.handleWheelClick(e, colorKey);
            });
        });
        // Brightness slider listeners
        this.shadowRoot.querySelectorAll(".brightness-slider").forEach(slider => {
            slider.addEventListener("input", (e) => {
                const colorKey = e.target.dataset.colorkey;
                const v = parseInt(e.target.value);
                const valueDisplay = this.shadowRoot.querySelector(`#brightness-value-${colorKey}`);
                if (valueDisplay) valueDisplay.textContent = v;
                const currentColor = this._config.colors?.[colorKey] || DEFAULT_COLORS[colorKey];
                const rgb = this.hexToRgb(currentColor);
                if (rgb) {
                    const hsv = this.rgbToHsv(rgb.r, rgb.g, rgb.b);
                    const newRgb = this.hsvToRgb(hsv.h, hsv.s, v);
                    const hex = this.rgbToHex(newRgb.r, newRgb.g, newRgb.b);
                    this.updateColor(colorKey, hex);
                }
            });
        });
    }
}

customElements.define("schedule-state-card", ScheduleStateCard);
customElements.define("schedule-state-card-editor", ScheduleStateCardEditor);
console.info("%c Schedule State Card %c v1.1.1 %c", "background:#2196F3;color:white;padding:2px 8px;border-radius:3px 0 0 3px;font-weight:bold", "background:#4CAF50;color:white;padding:2px 8px;border-radius:0 3px 3px 0", "background:none");
window.customCards = window.customCards || [];
window.customCards.push({
    type: "schedule-state-card",
    name: "Schedule State Card",
    description: "Visualizes schedules defined via Schedule_state with color customization."

});
